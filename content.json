{"meta":{"title":"一路生花","subtitle":null,"description":null,"author":"nty","url":"https://nty99.gitee.io","root":"/"},"pages":[{"title":"404","date":"2022-08-26T08:27:15.000Z","updated":"2022-08-26T08:57:11.184Z","comments":true,"path":"404/index.html","permalink":"https://nty99.gitee.io/404/","excerpt":"","text":""},{"title":"关于","date":"2022-08-22T01:50:10.000Z","updated":"2022-09-11T15:35:41.014Z","comments":true,"path":"about/index.html","permalink":"https://nty99.gitee.io/about/","excerpt":"","text":""},{"title":"说说","date":"2022-09-26T06:45:35.799Z","updated":"2022-09-26T06:45:35.789Z","comments":true,"path":"artitalk/index.html","permalink":"https://nty99.gitee.io/artitalk/","excerpt":"","text":""},{"title":"分类","date":"2022-08-21T15:48:43.000Z","updated":"2022-10-05T15:38:07.394Z","comments":true,"path":"categories/index.html","permalink":"https://nty99.gitee.io/categories/","excerpt":"","text":""},{"title":"留言板","date":"2018-09-30T09:25:30.000Z","updated":"2022-10-13T14:27:04.056Z","comments":true,"path":"contact/index.html","permalink":"https://nty99.gitee.io/contact/","excerpt":"","text":""},{"title":"捐赠","date":"2022-10-13T11:52:07.000Z","updated":"2022-10-13T11:54:52.499Z","comments":true,"path":"donate/index.html","permalink":"https://nty99.gitee.io/donate/","excerpt":"","text":""},{"title":"🐈随 笔","date":"2020-10-07T07:23:38.000Z","updated":"2022-10-07T06:14:39.836Z","comments":true,"path":"essay/index.html","permalink":"https://nty99.gitee.io/essay/","excerpt":"","text":""},{"title":"书单","date":"2020-11-03T09:01:05.000Z","updated":"2022-10-13T11:50:31.896Z","comments":true,"path":"books/index.html","permalink":"https://nty99.gitee.io/books/","excerpt":"","text":""},{"title":"收藏","date":"2020-08-17T09:09:06.000Z","updated":"2022-10-13T03:56:14.857Z","comments":true,"path":"collection/index.html","permalink":"https://nty99.gitee.io/collection/","excerpt":"","text":""},{"title":"统计","date":"2020-10-03T09:01:05.000Z","updated":"2022-10-13T03:56:41.891Z","comments":true,"path":"count/index.html","permalink":"https://nty99.gitee.io/count/","excerpt":"","text":""},{"title":"相册","date":"2020-10-03T09:01:05.000Z","updated":"2022-10-14T01:36:03.563Z","comments":true,"path":"gallery/index.html","permalink":"https://nty99.gitee.io/gallery/","excerpt":"","text":""},{"title":"lab","date":"2020-10-14T09:01:05.000Z","updated":"2022-10-07T06:52:38.714Z","comments":true,"path":"lab/index.html","permalink":"https://nty99.gitee.io/lab/","excerpt":"","text":""},{"title":"qingdan","date":"2020-10-03T09:01:05.000Z","updated":"2022-10-07T06:52:08.334Z","comments":true,"path":"qingdan/index.html","permalink":"https://nty99.gitee.io/qingdan/","excerpt":"","text":""},{"title":"音乐","date":"2020-10-09T09:08:05.000Z","updated":"2022-10-13T12:58:12.830Z","comments":true,"path":"musics/index.html","permalink":"https://nty99.gitee.io/musics/","excerpt":"","text":""},{"title":"友链","date":"2022-08-26T03:47:35.000Z","updated":"2022-10-13T15:18:59.125Z","comments":true,"path":"friends/index.html","permalink":"https://nty99.gitee.io/friends/","excerpt":"","text":""},{"title":"标签","date":"2022-08-22T01:49:45.000Z","updated":"2022-09-09T06:57:31.068Z","comments":true,"path":"tags/index.html","permalink":"https://nty99.gitee.io/tags/","excerpt":"","text":""},{"title":"vlog","date":"2020-10-10T09:08:05.000Z","updated":"2022-10-07T06:51:39.061Z","comments":true,"path":"videos/index.html","permalink":"https://nty99.gitee.io/videos/","excerpt":"","text":""},{"title":"ticktack","date":"2020-10-14T09:01:05.000Z","updated":"2022-10-07T06:51:24.165Z","comments":true,"path":"ticktack/index.html","permalink":"https://nty99.gitee.io/ticktack/","excerpt":"","text":""},{"title":"🐈博客主题开源投票","date":"2020-11-03T07:23:38.000Z","updated":"2022-10-07T06:51:52.366Z","comments":true,"path":"vote/index.html","permalink":"https://nty99.gitee.io/vote/","excerpt":"","text":""},{"title":"仓库","date":"2022-08-23T03:11:53.583Z","updated":"2022-08-23T03:11:53.572Z","comments":false,"path":"repository/index.html","permalink":"https://nty99.gitee.io/repository/","excerpt":"","text":""},{"title":"友情链接","date":"2022-08-23T03:59:28.711Z","updated":"2022-08-23T03:59:28.706Z","comments":true,"path":"links/index.html","permalink":"https://nty99.gitee.io/links/","excerpt":"","text":""},{"title":"乖乖照片","date":"2020-10-03T09:01:05.000Z","updated":"2022-10-08T08:14:17.336Z","comments":true,"path":"gallery/乖乖照片/index.html","permalink":"https://nty99.gitee.io/gallery/%E4%B9%96%E4%B9%96%E7%85%A7%E7%89%87/","excerpt":"","text":"jsonpCallback=BusuanziCallback_81138573042 jsonpCallback=BusuanziCallback_749006966160"},{"title":"日常风景","date":"2020-10-03T09:01:05.000Z","updated":"2022-10-07T12:10:38.899Z","comments":true,"path":"gallery/日常风景/index.html","permalink":"https://nty99.gitee.io/gallery/%E6%97%A5%E5%B8%B8%E9%A3%8E%E6%99%AF/","excerpt":"","text":""}],"posts":[{"title":"博客更新记录","slug":"博客更新记录","date":"2022-10-11T16:00:00.000Z","updated":"2022-10-14T03:36:18.512Z","comments":true,"path":"2022/10/12/blogRecord/","link":"","permalink":"https://nty99.gitee.io/2022/10/12/blogRecord/","excerpt":"","text":"v0.0.91、时间 2022年10月14日 11:20:00 2、迭代记录 1、更新主题样式、调整全局背景、更换文章图片、更换logo 2、删除Daovoice，新增书单、网址收藏、打赏记录，更好vlog、音乐、相册位置 3、修改关于页面内容、修改在线评论样式 4、首页新增语录、新增介绍 5、新增数据结构算法文章(Todo) v0.0.81、时间 2022年9月22日 23:26:00 2、迭代记录 1、新增博客静止时彩带显示 2、更新Linux文章 2、新增Maven文章 v0.0.71、时间 2022年9月18日 20:50:00 2、迭代记录 1、调整文章目录结构 2、新增Git文章 v0.0.61、时间 2022年9月14日 00:06:00 2、迭代记录 1、新增文章目录二级标题 2、修正部分文章排版问题、补充部分文章内容 3、添加部分乖乖照片至相册 v0.0.51、时间 2022年9月12日 22:30:00 2、迭代记录 1、新增文章摘要 2、优化文章中代码块显示 3、新增主页背景视频展示、调整全局页面动画效果 4、主页新增音乐、视频功能 5、更新关于页面相册照片 6、博客文章更细致拆分 7、修改友情链接内容 v0.0.41、时间 2022年9月1日 11:08:00 2、迭代记录 1、修复主页地址问题 2、优化文章url路径 2、修复中文文章链接显示问题 3、仓库迁移 v0.0.31、时间 2022年8月31日 09:23:00 2、迭代记录 1、新增评论功能 2、新增腾讯蛙互动功能 v0.0.21、时间 2022年8月29日 09:23:00 2、迭代记录 1、新增博客内容全局搜索 2、新增在线聊天功能，对接微信小程序提醒接口 v0.0.11、时间 2022年8月26日 14:55:20 2、迭代记录 1、初始化Gitee仓库、初始化博客配置信息、初始化文章信息 老板您好！感谢光临小店激活卡密：5B7D-4C3A-E3C3-6F07操作步骤：http://hk.liyihao.cn/?t=21、进入网站，选择卡密登陆、2、把您要下载的素材链接的链接复制到网站即可使用3、确认收货评后可领取设计软全集字体PPT模板等","categories":[{"name":"生活","slug":"生活","permalink":"https://nty99.gitee.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"aa","slug":"aa","permalink":"https://nty99.gitee.io/tags/aa/"}]},{"title":"数据结构与算法","slug":"算法","date":"2022-09-23T02:37:20.000Z","updated":"2022-10-13T15:21:14.073Z","comments":true,"path":"2022/09/23/algorithm/","link":"","permalink":"https://nty99.gitee.io/2022/09/23/algorithm/","excerpt":"","text":"一、时间复杂度1、概述 描述 增长数量级 说明 举例 常数 1 普通语句 两数相加 对数 logn 二分策略 二分查找 线性 n 循环 找出最大数 线性对数 nlogn 分治思想 归并排序 平方 n^2 双层循环 检查所有元素对 立方 n^3 三层循环 检查所有三元组 指数 2^n 穷举查找 检查所有子集 2、时间复杂度排序​ O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) 。 二、简单排序1、冒泡排序​ 1、排序原理 ​ 比较相邻的元素，如果前一个比后面大则交换两个元素的位置。 ​ 2、举例 ​ 7，4，3，6，8，选取7和4比较，如果7大于4则交换位置，再和3比较交换位置，直到8停下进行下一轮。 ​ 3、代码 //外层循环表示需要排序多少次，内层循环表示每次多少个元素参与排序 public static int[] sort(int[] array){ int temp; for (int i = array.length-1; i &gt; 0; i--) { for (int j = 0; j &lt; i; j++) { if (array[j]&gt;array[j+1]){ temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; } } } return array; } 2、选择排序​ 1、排序原理 ​ 在每次循环中，假定最小值的索引是第一位，依次与其它数做比较，如果比其它数大则交互位置，更新最小索引位置。 ​ 2、举例 ​ 7，4，3，6，8。选定索引0为数字最小的值，与4做比较，4比较小则更新最小索引，后续接着比较。 ​ 3、代码 //注意：这里使用异或交换两数的时候，要排除 minIndex 和 i 相等的情况 public static int[] sort(int[] array){ for (int i = 0; i &lt;= array.length()-2; i++) { int minIndex = i; for (int j = i + 1; j &lt;= array.length()-1; j++) { if (array[j]&gt;array[j+1]){ minIndex = j; } } if(minIndex == i)continue; array[i] = array[i] ^ array[minIndex]; array[minIndex] = array[i] ^ array[minIndex]; array[i] = array[i] ^ array[minIndex]; } return array; } 3、插入排序​ 1、排序原理 ​ 将数据分成两份，一份是已经排序完hasSort，一部分未排序unSort，依次取unSort中的值与hasSort的值循环比较，直到比hasSort选取的值大则进行下一轮循环。 ​ 2、举例 ​ 2，3，4，6，8，2和3是排完序，剩余未排序，选择3的值按倒序做比较，先与4比，小则交换位置，然后3再与2比，大则退出循环，再选取6做比较。 ​ 3、代码 public static int[] sort(int[] array){ for (int i = 1; i &lt;= array.length-1; i++) { for (int j = i; j &gt; 0; j--) { //最后(array[j-1])的肯定是最大的，如果array[j]比最后都大则退出循环 if (array[j-1] &gt; array[j]) { array[j-1] = array[j-1] ^ array[j]; array[j] = array[j-1] ^ array[j]; array[j-1] = array[j-1] ^ array[j]; }else break; } } return array; } 三、高级排序1、希尔排序 TODO","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://nty99.gitee.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Maven进阶知识点","slug":"Maven","date":"2022-09-18T14:56:45.000Z","updated":"2022-10-05T15:22:17.641Z","comments":true,"path":"2022/09/18/maven/","link":"","permalink":"https://nty99.gitee.io/2022/09/18/maven/","excerpt":"","text":"一、依赖管理1、可选依赖​ 在依赖下添加optional标签，表示对外隐藏当前依赖的资源，隐藏后对应的资源不具有传递性。如A的pom中引用B，B的某个依赖下设置了optional标签的值为true，则A中不会引入B中的那个依赖，但B不受影响。 &lt;dependency&gt; &lt;groupId&gt;xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 2、排除依赖​ 在依赖下添加exclusions、exclusion标签，表示排除该依赖下的某些依赖。 &lt;dependency&gt; &lt;groupId&gt;xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 二、聚合与继承1、聚合​ 聚合是指通过一个父工程来管理若干个子工程。在父工程的pom中添加packaging，值设置为pom(不设置默认为jar)，然后添加modules、module标签，写上子模块名称。子模块顺序没影响，打包的顺序是根据各个模块的依赖决定的。 &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;model-demo&lt;/module&gt; &lt;module&gt;server-demo&lt;/module&gt; &lt;module&gt;order-demo&lt;/module&gt; &lt;/modules&gt; 2、继承​ 继承是描述的多个工程之间的关系，子工程可以继承父工程的信息，这样的可以简化配置、减少版本冲突。在子工程中添加parent标签，引入父工程的坐标，这样父工程依赖的内容可以传递给子工程。公共的功能可在父工程中添加dependencies标签，这样每个子工程都会继承。父工程添加dependencyManagement标签，只是对依赖进行了版本控制，子类可按自己需求去添加该依赖。 &lt;parent&gt; &lt;groupId&gt;xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!--公共依赖，会传递给子类--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--对依赖进行版本控制，不会传递给子类--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 三、属性1、属性列表​ maven总共有五种属性，如下： 属性分类 引用格式 示例 自定义属性 ${自定义属性} ${spring.version} 内置属性 ${内置属性} ${project.basedir}、{basedir} Setting属性 ${setting.属性名} ${settings.localRepository} Java属性 ${系统属性分类.系统属性名} ${user.name} 环境变量属性 ${env.环境变量属性名} ${env.JAVA_HONE} ​ （1）自定义属性：自定义属性是最常用的，可以对版本进行统一管理，解决版本不一致、重复问题。在工程中添加properties标签，写上名称。然后在依赖中写版本名称就可以了。 &lt;properties&gt; &lt;spring.version&gt;5.1.1&lt;/spring.version&gt; &lt;xxx.version&gt;1.0.0&lt;/xxx.version&gt; &lt;/properties&gt; &lt;dependency&gt; &lt;groupId&gt;xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;${xxx.version}&lt;/version&gt; &lt;/dependency&gt; ​ （2）Setting属性：读取maven本地安装目录里面的settings.xml里面的配置信息。 ​ （3）Java系统变量、环境变量属性：通过mvn help:system查看。 2、属性扩大​ 当我们想在配置文件中读取pom中定义的属性怎么办？此时可以在pom中这样配置，然后使用${属性名称}就可以了。 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;${project.basedir}/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 四、多环境配置(了解)​ 在pom文件中配置profiles标签，然后配置多个profile子标签代表多个环境，配置activation代表默认使用哪个环境。也可以使用maven命令mvn 指令 -p 环境id代表打包时候指定环境，例如mvn install -p dev。 &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;db.ip&gt;127.0.0.1&lt;/db.ip&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;db.ip&gt;121.111.11.1&lt;/db.ip&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 五、跳过测试(了解)​ 当我们执行maven中test后面的命令时，总是会先执行test命令，但有些场景不需要执行test，如何解决这个问题？有三种方法，如下： ​ （1）有集成工具，如IDEA中，点maven模块又上角的闪电(2022.2新UI之前的版本)，新UI之后在maven模块右边有个按钮可以直接掉过测试。 ​ （2）通过在build标签里面配置，如下： &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.2&lt;/version&gt; &lt;configuration&gt; &lt;!--全局，true都跳过--&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;!--也可对哪些类进行单独配置，includes包含，excludes排除--&gt; &lt;includes&gt;**/Xxx.java&lt;/includes&gt; &lt;excludes&gt;**/Xxx.java&lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; ​ （3）通过mvn命令执行，例如mvn package -D skipTests 六、私服​ 所谓私服也就是搭建自己的中央仓库。 1、仓库分类 仓库分类 英文名称 功能 关联操作 宿主仓库 hosted 保存自主研发+第三方仓库(如中央仓库下载不到的) 上传 代理仓库 proxy 代理连接中央仓库 下载 仓库组 group 为仓库编组简化下载操作 下载 2、访问私服配置​ 在maven的settings.xml中进行配置。 ​ （1）访问私服权限 &lt;server&gt; &lt;id&gt;私服仓库名称&lt;/id&gt; &lt;username&gt;xxx&lt;/username&gt; &lt;password&gt;xxx&lt;/password&gt; &lt;/server&gt; ​ （2）访问私服路径 &lt;mirror&gt; &lt;id&gt;仓库组id&lt;/id&gt; &lt;mirrorOf&gt;进行什么操作会走这个仓库&lt;/mirrorOf&gt; &lt;name&gt;名称&lt;/name&gt; &lt;url&gt;仓库组路径&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;public&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt; 3、私服上传和下载​ 在项目pom工程中添加distributionManagement标签，根据项目的version标签后缀的值，为release表示部署到repository标签对应的url仓库，为snapshot则表示部署到snapshotRepository标签对应的url仓库。 &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;release&lt;/id&gt; &lt;url&gt;xxx&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshot&lt;/id&gt; &lt;url&gt;xxx&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"https://nty99.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"Git","slug":"Git","date":"2022-09-14T06:54:57.000Z","updated":"2022-10-05T15:21:37.547Z","comments":true,"path":"2022/09/14/git/","link":"","permalink":"https://nty99.gitee.io/2022/09/14/git/","excerpt":"","text":"一、介绍​ Git是一款开源的分布式版本控制系统，用于敏捷高效的处理任何大或小的项目。 二、Git环境配置​ git config控制git的行为，来定义环境变量，它提供三个环境参数，system、global、local。当使用如下命令配置时，不同的参数会写到不同的配置文件中。 git config --system xxx.xxx --system #针对任意登录该linux系统的用户都生效，git的配置信息，写入到/etc/gitconfig --global #全局，只针对当前登录的用户生效，git配置信息，写入到~/.gitconfig(使用最多) --local #本地，只对某个git管理的项目生效，git配置信息，写入到/管理的文件/.git/config 三、用户git信息配置git config --system --list #查看系统所有linux用户的通用配置，此命令检查安装目录下的/etc/gitconfig git config --global --list #查看当前linux用户的配置，此命令检查~/.gitconfig git config --local --list #查看git目录中仓库配置文件，此命令检查.git/config git config --global user.name \"\" #配置当前linux用户全局用户名，这台机器所有仓库都使用该配置 git config --global user.email \"\" #配置当前linux用户全局邮箱 git config --global color.ui true #配置git语法高亮 git config --global --unset user.name #删除某个配置 git config --list #列出git能找到的所有配置，从不同的文件中读取所有结果 git config user.name #列出git的某项配置 git config --global credential.helper store #解决git每次提交和拉取代码需要输入用户名和密码问题 git config --global alias.ci commit #别名ci是commit的别名,然后git ci等价于git commit core.editor #文本编辑器 merge.tool #差异分析工具 core.paper \"less -N\" #配置显示方式 color.diff true #diff颜色配置 git config core.filemode false #忽略修改权限的文件 四、Git的工作区域​ git分为4个工作区域，工作区、暂存区、本地仓库、远程仓库。git命令实质就是用于记录文件在不同区域的改动。 五、本地仓库结构​ git init或者git clone克隆项目后，会生成.git的隐藏文件，也就是本地仓库，其目录结构如下： . ├── HEAD #git的文件指针，映射到refs引用 ├── config #该git项目独有的配置 ├── description #仓库的描述信息，主要给gitweb等git托管系统使用 ├── COMMIT_EDITMSG #最新提交的一次Commit Message，git系统不会用到，给用户一个参考 └── logs #保存所有更新的引用记录 ├── HEAD #记录所有分支的版本的变动信息 └── refs └── heads #记录各个分支的版本变动记录 └── remotes #记录对远程的操作 ├── FETCH_HEAD #是一个版本链接，指向着目前已经从远程仓库取下来的分支的末端版本 ├── ORIG_HEAD #HEAD指针的前一个状态，在logs/HEAD中，最后一条提交记录，当前hash值 ├── hooks #存放一些shell脚本 ├── index #保存暂存区的信息，二进制文件 ├── packed-refs #当更新一个引用时，git不会packed-refs，而是会在refs/heads下写入一个新文件。当查找一个引用时，git首先在refs目录下查找，如果未找到则到packed-refs文件中去查找 ├── info │ └── exclude #存放仓库的一些信息 ├── objects #存放所有的git对象，例如git log里面的commit_id可以在里面找到 └── refs ├── heads #保存各个分支最新的一次提交的哈希值 ├── remotes └── origin #远程分支的名称 ├── HEAD #存放下面分支的引用 └── master #记录最新的hash值 └── tags #记录当前分支所拥有的标签 └── v1.0 #存放标签的hash值 六、注意事项​ git仓库里面一定要使用git自带命令。如更改文件名称，如果使用mv test.sh test1.sh，则实质会删除test.sh然后重新创建test1.sh，并且没有被git跟踪。使用git mv test.sh test1.sh则没问题。 nty@work git_repo % git status On branch master Changes not staged for commit: (use \"git add/rm &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) deleted: test.sh Untracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) test1.sh no changes added to commit (use \"git add\" and/or \"git commit -a\") nty@work git_repo % 七、基本流程操作1、初始化仓库#在当前分支初始化git仓库 git init #创建名称为blog的git仓库 git init blog #以https的方式从远程克隆仓库 git clone https://gitee.com/nty99/nty99.git #以ssh的方式从远程克隆仓库 git clone git@gitee.com:nty99/nty99.git 2、添加变动至暂存区#查看工作区文件状态 git status #添加所有变动的文件至git管理，即将工作区的未跟踪文件、修改的文件、删除的文件全部添加到暂存区 git add . #添加具体的一个或多个文件至暂存区 git add 具体文件... 3、提交至本地仓库#提交暂存区的文件至本地仓库，推荐加上-m，不然需自己在vim编辑器里面添加注释 git commit -m \"注释\" #相当于git add . + git commit -m \"注释\"，前提是文件被git管理 git commit -am \"注释\" #修改最新提交的注释信息，注意此时的commit_id会变化，可通过git reflog查看变化记录 git commit --amend -m \"修改\" 4、提交至代码托管平台#将本地仓库master分支文件添加到远程仓库origin，更多提交参数请调至14小节查看 git push origin master 八、Git删除操作1、rm直接删除​ （1）未被git管理：和平常使用的文件一样，rm删除就行了。 ​ （2）被git管理：rm效果是删除工作区的文件，如果想把删除提交到本地仓库，还需要git add和git commit。 nty@work git_repo % rm test.sh nty@work git_repo % git status On branch master Changes not staged for commit: (use \"git add/rm &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) deleted: test.sh no changes added to commit (use \"git add\" and/or \"git commit -a\") nty@work git_repo % git add . nty@work git_repo % git status On branch master Changes to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) deleted: test.sh 2、git rm​ 注意：以下三种都是针对被git管理的文件。 #注意 git rm删除的文件必须是和版本库的内容是一致的 #git rm会删除工作区的文件，同时将删除的文件添加到暂存区，相当于rm + git add git rm test.sh #将文件从暂存区和工作区中删除 nty@work git_repo % git rm test.sh rm 'test.sh' nty@work git_repo % git status On branch master Changes to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) deleted: test.sh 3、git rm -f#当工作区的内容改动后，再想使用git rm命令时，必须添加-f nty@work git_repo % echo \"echo add file\" &gt;&gt; test.sh nty@work git_repo % git rm test.sh error: the following file has local modifications: test.sh (use --cached to keep the file, or -f to force removal) nty@work git_repo % git rm -f test.sh rm 'test.sh' nty@work git_repo % git status On branch master Changes to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) deleted: test.sh 4、git rm –cached#会删除暂存区中的文件，但是会保留工作区中的文件(工作区取消了git跟踪)，并将此次删除提交到暂存区 git rm --cached test.sh nty@work git_repo % git rm --cached test.sh rm 'test.sh' nty@work git_repo % git status On branch master Changes to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) deleted: test.sh Untracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) test.sh 九、Git查看版本信息1、git log#等价于git log --all,查看全部版本信息 nty@work git_repo % git log commit 271783295f98eaf41a63c8d9d9ae23c5c8206074 (HEAD -&gt; master) Author: 123 &lt;1115195406@qq.com&gt; Date: Thu Sep 15 10:56:29 2022 +0800 second commit commit 2d7c6a5ed6c30372d4936258b4f7ee5acb0011b6 Author: nty &lt;1115195406@qq.com&gt; Date: Wed Sep 14 23:39:55 2022 +0800 first commit 2、git log –onlie#一行显示,简略的显示git版本信息 nty@work git_repo % git log --oneline 2717832 (HEAD -&gt; master) second commit 2d7c6a5 first commit 3、git log –all –graph#用字符图形化显示git版本信息 nty@work git_repo % git log --graph * commit 271783295f98eaf41a63c8d9d9ae23c5c8206074 (HEAD -&gt; master) | Author: 123 &lt;1115195406@qq.com&gt; | Date: Thu Sep 15 10:56:29 2022 +0800 | | second commit | * commit 2d7c6a5ed6c30372d4936258b4f7ee5acb0011b6 Author: nty &lt;1115195406@qq.com&gt; Date: Wed Sep 14 23:39:55 2022 +0800 first commit 4、git log -n#显示最新的n条记录 nty@work git_repo % git log -1 commit 271783295f98eaf41a63c8d9d9ae23c5c8206074 (HEAD -&gt; master) Author: 123 &lt;1115195406@qq.com&gt; Date: Thu Sep 15 10:56:29 2022 +0800 second commit commit 2d7c6a5ed6c30372d4936258b4f7ee5acb0011b6 Author: nty &lt;1115195406@qq.com&gt; Date: Wed Sep 14 23:39:55 2022 +0800 first commit 5、git log –stat#显示所有提交记录的文件更改信息 nty@work git_test % git log --stat commit 11cae91801a4f08c6473d191b129a60bf09cd3dc (HEAD -&gt; master) Author: nty &lt;1115195406@qq.com&gt; Date: Thu Sep 29 20:27:25 2022 +0800 test a.txt | 1 + 1 file changed, 1 insertion(+) #查看某一次提交的文件修改列表 nty@work git_test % git log --stat 11cae91 commit 11cae91801a4f08c6473d191b129a60bf09cd3dc (HEAD -&gt; master) Author: nty &lt;1115195406@qq.com&gt; Date: Thu Sep 29 20:27:25 2022 +0800 test a.txt | 1 + 1 file changed, 1 insertion(+) nty@work git_test % git show --stat 11cae91 commit 11cae91801a4f08c6473d191b129a60bf09cd3dc (HEAD -&gt; master) Author: nty &lt;1115195406@qq.com&gt; Date: Thu Sep 29 20:27:25 2022 +0800 test a.txt | 1 + 1 file changed, 1 insertion(+) 6、git log –author#显示某个作者的日志记录 nty@work git_test % git log --author='nty' commit 11cae91801a4f08c6473d191b129a60bf09cd3dc (HEAD -&gt; master) Author: nty &lt;1115195406@qq.com&gt; Date: Thu Sep 29 20:27:25 2022 +0800 test #查看某人提交的多少次 nty@work git_test % git log --author=nty | grep commit | wc -l 1 十、Git撤销操作​ 当我们写完代码，add、commit后，此时想撤销commit或者add时候，怎么办？首先我们要了解，git是通过指针进行版本管理，那个指针就是HEAD，HEAD表示当前的版本，HEAD^表示上个版本，HEAD^^表示上上个版本。此时可以使用reset来完成版本变更。git reset有三种方式： ​ （1）–mixed：不删除工作空间改动代码，撤销commit，并且撤销git add操作。该参数为默认参数。 #回退到上个版本 git reset --mixed HEAD^ #回退到指定版本 git reset --mixed 4e107ff ​ （2）–soft：不删除工作空间改动代码，撤销commit，不撤销git add。 git reset --soft HEAD^ ​ （3）–hard：删除工作空间改动代码，撤销commit，撤销git add。 git reset --hard HEAD^ 1、git reset#git reset --hard HEAD^ 回退到上个版本 nty@work git_repo % git reset --hard HEAD^^^ HEAD is now at bcae92e third delete #git reset --hard 版本号ID 回退到指定版本 nty@work git_repo % git reset --hard 4e107ff HEAD is now at 4e107ff git rm -f test 2、git reflog​ 查看git所有版本变动记录。 3、git checkout​ checkout除了常用的切换分支功能外，还有还原操作。有如下场景，我们修改了一个文件Test.java，但是想用git还原，此时怎么办?此时需要考虑三种情况: ​ （1）还在工作区 git checkout -- Test.java #还原所有变动文件 git checkout -- . ​ （2）提交到暂存区 #回退到当前版本，撤销add，然后checkout还原 git reset HEAD git checkout -- Test.java ​ （3）提交到本地仓库 #撤销commit，撤销add，checkout还原。也可以直接git reset --hard HEAD^直接撤销操作并且将改动的记录删除。 git reset HEAD^ git checkout -- Test.java 十一、Git文件暂存​ git stash就是把暂存区中还没提交的文件临时存放到一个区域，以便于其它操作。 git stash save \"存储\" #不自定义注释的话可以简写成git stash,临时保存暂存区的数据 git stash list #查看stash保存的列表及id git stash pop #恢复最新的stash记录 git stash pop id #恢复指定的stash记录 git stash clear #清空所有stash记录 git stash drop id #删除某个stash记录 十二、Git分支1、注意：​ （1）git branch nty或者git checkout -b nty创建的新分支都是以当前分支的最新状态创建的。 ​ （2）只要文件没有在某个分支commit过，则可以在任何分支看到此文件。 ​ （3）在某个分支修改、删除一个提交过的文件，此时必须在当前分支提交后才能切换到其它分支。 2、分支信息查看git branch #查看本地所有分支,并以星号标识当前所在的分支 git branch -r #显示远程分支信息 git branch -a #显示本地、远程所有分支 git branch -vv #查看当前分支与远程分支的跟踪关系 3、分支创建、切换、跟踪#创建新分支 git branch nty #切换分支 git checkout nty #创建新分支并且立即切换 git checkout -b nty #切换到标签对应的版本，因为tag相当于是一个快照，此时切换过去后不能修改代码 git checkout tag_name #根据tag对应的版本创建新分支nty，这样就能操作了 git checkout -b nty tag_name #创建nty分支并追踪origin/nty，前提是本地没有该分支且远程必须有此分支 git checkout -b nty origin/nty #创建nty分支并追踪origin/nty，前提是本地没有该分支且远程必须有此分支 git branch --track nty origin/nty #设置nty分支跟踪远程nty分支,如果nty不写分支则默认设置当前分支跟踪，分支必须存在 git branch --set-upstream-to origin/nty nty #设置nty分支跟踪远程分支，如果nty不写则默认设置当前分支，分支必须存在 git branch -u origin/nty nty #将本地nty分支修改成nty1分支 git branch -m nty nty1 4、分支删除git branch -d nty #删除分支，只有当前分支和目标分支完全合并后才能删除 git branch -D nty #强制删除分支 git branch -d -r nty #删除远程分支，删除后还需git push 5、分支合并git merge nty #合并分支 #git merge 冲突后，需手动查看冲突文件，修改后，git add file解决冲突 十三、Git标签​ 给提交的版本记录打上一个标记，更好的记录版本信息。 git tag #查看所有标签 git show 标签名称 #显示标签信息以及关联的版本记录信息 git tag -a v1.0 -m \"第一个版本\" #给最新版本记录新建标签并说明标签注释 git tag -a v0.9 commit_id -m \"注释\" #给指定版本打上标签并说明标签注释 git log --oneline --decorate #显示简略日志版本号和对应标签信息 git tag -d 标签名称 #删除标签 十四、Git远程​ 将本地仓库与远程代码托管平台进行关联，如Gitee、GitHub、GitLab。 1、查看、关联#查看远程仓库的名字 git remote #修改远程仓库的名字 git remote rename origin origin1 #查看关联的远程仓库地址 git remote -v #与远程仓库(可多个)建立连接，origin是给远程仓库起的名称，后面是远程仓库地址 git remote add o rigin https://xxx #显示远程的配置信息 git show-ref 2、拉取​ （1）fetch #这个命令将某个远程主机的更新全部取回本地 git fetch &lt;远程主机名&gt; #如果只想取回特定分支的更新，可以指定分支名 git fetch &lt;远程主机名&gt; &lt;分支名&gt; #将远程的分支内容拉取到本地dev分支 git fetch &lt;远程主机名&gt; &lt;分支名&gt;:dev #取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息 git log -p FETCH_HEAD ​ （2）pull #git pull等价于git fetch + git merge FETCH_HEAD #将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; #如果远程分支是与当前分支合并，则冒号后面的部分可以省略 git pull origin master 3、推送#将本地master分支代码推送到远程origin仓库master分支 git push origin master:refs/for/master #如果远程分支被省略，则表示将本地分支推送到与之存在追踪关系的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建 git push origin master #如你创建分支但是没有设置跟踪，提交时候加上-u，这样提交后就会设置跟踪了，下次提交可简写成git push git push -u origin master #如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于git push origin --delete master git push origin:refs/for/master #如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 git push origin #如果当前分支只有一个远程分支，那么主机名都可以省略 git push","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"VCS","slug":"VCS","permalink":"https://nty99.gitee.io/tags/VCS/"}]},{"title":"设计模式知识点","slug":"设计模式","date":"2022-09-13T06:53:20.000Z","updated":"2022-10-05T15:21:04.825Z","comments":true,"path":"2022/09/13/design/","link":"","permalink":"https://nty99.gitee.io/2022/09/13/design/","excerpt":"","text":"一、创建型模式​ 主要特点是将对象的创建和使用分离。 1、单例模式​ 1、分类 ​ （1）饿汉式：类加载就会导致该实例对象被创建 ​ （2）懒汉式：首次使用该对象才会创建 ​ 2、实现方式 ​ （1）双重检查锁+volatile关键字 ​ （2）静态类部类方式 ​ （3）枚举方式，推荐 ​ 3、破坏方法 ​ （1）序列化：解决方案:在序列化的类中新增readResolve()方法,ObjectInputStream会判断有无这个方法，有就执行。 ​ （2）反射：解决方案：通过构造方法创建对象时候，添加判断(多线程环境加上同步代码块)。 ​ 4、代码 public class Singleton1 implements Serializable { private static boolean flag = false; /** * 防止反射破外单例模式 */ private Singleton1() { synchronized (Singleton1.class) { if (flag) { throw new RuntimeException(\"已经创建了对象\"); } flag = true; } } /** * 防止序列化破外单例模式 */ public Object readResolve(){ return Singleton1.getInstance(); } /** * 多线程情况下，由于JVM实例化对象会进行优化和指令重排序,使用volatile保证可见性和有序性 */ private static volatile Singleton1 instance; public static Singleton1 getInstance() { //双重检查锁(DCL) if (instance == null) { synchronized (Singleton1.class) { if (instance == null) { instance = new Singleton1(); } } } return instance; } } 2、工厂方法模式​ 1、分类 ​ （1）简单工厂模式 ​ （2）抽象工厂模式 ​ 2、抽象工厂使用场景 ​ （1）当创建的对象是一系列相互关联或相互依赖的产品族，如电器工厂的洗衣机、电视剧、冰箱。 ​ （2）系统中有多个产品族，但每次只使用某一族产品。如穿不同品牌的衣服、鞋子。 ​ （3）系统中提供了产品的类库，且所有产品接口相同，客户端不依赖产品实例的创建细节和内部结构，如输入法皮肤更换等等。 3、原型模式​ 1、介绍 ​ 用一个已经创建的实例作原型，通过复制该原型对象来创建一个和原型对象相同的新对象。 ​ 2、角色 ​ （1）抽象原型类：规定了具体原型对象必须实现的clone()方法 ​ （2）具体原型类：实现抽象原型类的clone方法，它是可被复制的对象 ​ （3）访问类：使用具体原型类的clone方法复制新对象 ​ 3、使用场景 ​ （1）对象创建复杂，可使用原型模式快速克隆 ​ （2）性能和安全要求比较高 ​ 4、解释 ​ （1）浅克隆：Object的clone方法是浅克隆，克隆的新对象属性和原对象相同，对于非基本类型属性，克隆对象属性内存地址指向原有对象属性。 ​ （2）深克隆：克隆出新对象，原对象属性中的其它对象也会被克隆，不再指向原对象属性内存地址 4、建造者模式​ 1、介绍 ​ 将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示，不必通过构造方法根据参数创建对象，可以自己指定对象的属性。 ​ 2、使用场景 ​ （1）创建的对象较复杂，由多个部件构成，各部门面临复杂的变化，但是部件间的构造顺序的稳定的。 ​ （2）产品构建和装配方式是分离的，即产品的构建过程和最终的表示是相互独立的。 ​ 3、代码 Worker worker = new Worker.Builder() .name(\"xxx\") .age(23) .sex(\"男\") .build(); public class Worker { private String name; private Integer age; private String sex; private Worker(Builder builder) { this.name = builder.name; this.age = builder.age; this.sex = builder.sex; } static final class Builder{ private String name; private Integer age; private String sex; Builder name(String name){ this.name = name; return this; } Builder age(Integer age){ this.age = age; return this; } Builder sex(String sex){ this.sex = sex; return this; } public Worker build(){ return new Worker(this); } } } 5、模式对比​ 1、工厂方法模式VS建造者模式​ 工厂方法模式注重于整体对象的创建，建造者模式注重于部件的构建过程，意在通过一步步的精确构建出一个复杂的对象。 ​ 2、抽象工厂模式VS建造者模式​ 抽象工厂模式实现对产品家族的创建，一个产品家族是这样一系列产品；具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产。建造者模式主要目的是通过组装零配件产生一个新产品。 二、结构型模式​ 用于描述如何将对象按照某种布局组成更大的结构，分为类结构模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。后者耦合度低，满足”合成复用原则”,所以对象型结构模式比类结构型模式更灵活。 1、代理模式​ 1、分类 ​ （1）静态代理 ​ （2）动态代理，动态代理又分Jdk动态代理和Cglib动态代理 ​ 2、Jdk动态代理原理 ​ （1）调用proxyInstance.sellTicket()，根据多肽会执行动态代理动态生成的$Proxy0的sellTicket()方法。 ​ （2）根据构造方法生成$Proxy0对象，会将自定义的new InvocationHandler(){}传递给父类Proxy的构造方法，复制给父类的成员变量InvocationHandler。 ​ （3）执行super.h.invoke(this, m3, (Object[])null)方法会调用自己的invoke方法。 ​ （4）invoke方法中会通过反射调用真实对象的Proxy0的sellTicket()方法。 private static TrainStation station = new TrainStation(); SellTicket proxyInstance = (SellTicket) Proxy.newProxyInstance( station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"增强\"); return method.invoke(station, args); } }); proxyInstance.sellTicket(); public final class $Proxy0 extends Proxy implements SellTicket { private static Method m3; public $Proxy0(InvocationHandler var1) throws { super(var1); } public final void sellTicket() throws { super.h.invoke(this, m3, (Object[])null); } static { m3 = Class.forName(\"com.study.nty.design.proxy.SellTicket\").getMethod(\"sellTicket\"); } } ​ 3、Cglib动态代理原理 ​ （1）执行proxy.sellTicket()方法会执行MethodInterceptor对象的intercept方法。 ​ （2）Cglib底层采用ASM字节码生成框架，使用字节码技术生成代理类，Cglib不能对final修饰的类或方法进行代理，因为Cglib动态生产的类是目标对象的子类。 private static TrainStation station = new TrainStation(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(TrainStation.class); enhancer.setCallback( new MethodInterceptor() { @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(\"动态增强\"); return method.invoke(station,args); } }); TrainStation proxy = (TrainStation) enhancer.create(); proxy.sellTicket(); ​ 4、两者区别 ​ 动态代理会将接口或类中的方法集中在处理器的方法中执行，这样在目标对象的方法比较多的时候能灵活处理，不用像静态代理那样在每个方法都重写、处理。 ​ 5、优缺点 ​ （1）优点：代理模式中客户端和目标对象之间提供中介和保护作用，可以对象目标对象的功能进行增强，使客户端和目标对象分离，降低系统耦合度。 ​ （2）缺点：增加系统复杂度 2、适配器模式​ 将一个类的接口转换成客户希望的另外的接口，使得原本不能兼容的东西变成兼容。分为类适配器和对象适配器，前者耦合度比较高，应用少。 ​ 1、角色 ​ （1）目标接口(Target)：当前系统业务所期待的接口 ​ （2）适配者(Adaptee)：被访问和适配现存组件的接口 ​ （3）适配器(Adapter)：转换器，通过继承或引用适配者对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 3、装饰者模式​ 暂不展开说明。 4、桥接模式​ 1、角色 ​ （1）抽象化角色：定义抽象类，并包含对实现化角色的引用。 ​ （2）扩展抽象化角色：继承抽象化角色，重写父类方法，通过组合关系调用实现化角色的方法 ​ （3）实现化角色：定义接口，供扩展抽象化角色调用。 ​ （4）具体实现化角色：给出实现化角色的接口的具体实现。 5、门面模式​ 1、Web项目中的应用 ​ 在Tomcat中，提供了RequestFacade作为门面模式的类。 6、组合模式​ 1、角色 ​ （1）抽象根节点：定义系统各层次对象共有的方法和属性，可以预先定义一些默认方法和属性。 ​ （2）树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 ​ （3）叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 ​ 2、分类 ​ 透明模式、安全模式。 ​ 3、应用场景 ​ 如菜单模块，一级菜单下会有多个二级菜单，每个二级菜单下会有多个三级菜单。 7、享元模式​ 1、结构 ​ （1）内部状态：不会随环境改变而改变的可共享的部分 ​ （2）外部状态：指随环境的改变而改变的不可共享的部分 ​ 2、角色 ​ （1）抽象享元角色：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据(内部状态)，同时也可以通过这些方法来设置外部数据(外部状态)。 ​ （2）具体享元角色：实现了抽象享元类，称为享元对象。在具体享元类中为内部状态提供了存储空间。通常我们可以结合单利模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 ​ （3）非享元角色：并不是所有抽象享元类的子类需要被共享，不能被共享的子类可设计成非共享享元类。当需要非共享具体享元对象时候可以直接实例化创建。 ​ （4）享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时候，享元工厂检查是否存在符合要求的享元对象，如果存在则提供，不存在则创建。 三、行为型模式​ 用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。 1、模板方法模式​ 1、角色 ​ 抽象类和具体子类。 ​ （1）抽象类：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。 ​ （2）具体子类：实现抽象类中定义的抽象方法和钩子方法，它们是一个顶级逻辑的的组成步骤。 ​ 2、模版方法 ​ 定义了算法的骨架，按某种顺序调用其包含的基本方法。 ​ 3、基本方法 ​ 是实现算法各个步骤的方法，是模板方法的组成部分。基本方法也可以分为三种： ​ （1）抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。 ​ （2）具体方法：一个具体方法由一个抽象类或具体类声明实现，其子类可以覆盖也可以直接继承 ​ （3）钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法。一般钩子方法是用于判断的逻辑方法， 这种方法名一般为isXxx，返回值是boolean类型。 2、策略模式​ 1、使用场景 ​ （1）一个类需要动态的在几种算法中选择一种时，可将每个算法封装到策略类中。 ​ （2）系统中各算法彼此完全独立，且要求对客户端隐藏其算法细节时。 3、命令模式​ 1、角色 ​ （1）抽象命令类角色：定义命令的接口，声明执行的方法。 ​ （2）具体命令类角色：具体的命令，实现命令接口。通常会持有接受者，并调用接受者功能来完成命令操作 ​ （3）实现者/接受者角色：真正执行命令的对象，任何类都可能成为一个接受者，只要实现命令要求的功能。 ​ （4）调用者/请求者角色：调用命令对象执行请求，通常持有命令对象，可以只有很多命令对象。相当于使用命令对象的入口 ​ 2、应用场景 ​ 如去餐馆点餐，你(调用者)下命令给服务员(具体命令角色)，服务员传达给厨师(接受者角色)，厨师执行。 ​ 3、Jdk中应用 ​ Runnable是一个典型的命令模式，Runnable承担抽象命令角色，Thread担任调用者，Thread类的start方法是执行方法(入口)。 4、责任链模式​ 1、应用场景 ​ 例如公司假条审批，在我–&gt;负责人–&gt;主管–&gt;老板的层级审批的链路。 ​ 2、Web项目中的应用 ​ FilterChain是责任链的典型应用，Filter子实现类通过FilterChain组成链路调用。 5、状态模式​ 暂不展开说明。 6、观察者模式​ 1、Jdk中应用 ​ （1）Observable抽象目标类(发布者)，它有一个Vector集合成员变量，存储需要通知的观察者。当它的状态发生改变后(调用setChange方法)，然后去通知观察者(调用notifyObservers方法)。后添加到集合中的观察者会先收到通知。 ​ （2）Observer抽象观察者(消费者、订阅者)，它监视目标对象的变化，当收到通知后，会调用update方法工作。 7、中介者模式​ 暂不展开说明。 8、迭代器模式​ 1、Jdk中应用 ​ ArrayList的内部类Itr实现了Iterable接口，ArrayList中定义iterator方法，来获取具体迭代器。 9、访问者模式1、分派技术 ​ 1、概念 ​ 变量被声明时的类型叫做变量的静态类型，而变量引用对象的真实类型又叫做变量的实际类型。如Map map = new HashMap(); map变量的静态类型是Map，动态类型是HashMap。根据变量的类型而对方法进行的选择，叫做分派。 ​ 2、分类 ​ （1）静态分派：发生在编译时期，分派根据静态类型信息发生。方法重载就是静态分派。 ​ （2）动态分配：发生在运行时期，动态分派动态的置换某个方法。Java通过方法的重写支持动态分派。 ​ （3）双分派：指在选择一个方法的时候，不仅仅要根据消息接受者的运行时的区别，还要根据参数的运行时的区别。 ​ 3、例子(双分派) public class Animal { public void eat(){ System.out.println(\"动物吃饭\"); } } public class Cat extends Animal{ public void eat(){ System.out.println(\"猫吃饭\"); } } public class Dog extends Animal{ public void eat(){ System.out.println(\"狗吃饭\"); } /** * Animal a1 = new Animal(); 静态类型Animal，动态类型右边 * 调用printInfo方法，重载根据静态类型选择，所以都进入第一个方法。 * 调用animal.eat()方法，是真实对象调用，所以会执行真实类型的eat方法 */ public static void main(String[] args) { Animal a1 = new Animal(); Animal a2 = new Cat(); Animal a3 = new Dog(); printInfo(a1); printInfo(a2); printInfo(a3); } public static void printInfo(Animal animal){ System.out.println(\"animal\"); animal.eat(); } public static void printInfo(Cat cat){ System.out.println(\"cat\"); cat.eat(); } public static void printInfo(Dog dog){ System.out.println(\"dog\"); dog.eat(); } } 10、备忘录模式​ 暂不展开说明。 11、解释器模式​ 暂不展开说明。","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://nty99.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Logback","slug":"Logback","date":"2022-09-11T14:58:31.000Z","updated":"2022-10-05T15:22:02.572Z","comments":true,"path":"2022/09/11/log/","link":"","permalink":"https://nty99.gitee.io/2022/09/11/log/","excerpt":"","text":"一、日志两大规范​ 由于log4j性能问题，采用logback替代log4j。 ​ 1、Commons Logging (JCL) ​ 2、Simple Logging Facade for JAVA (slf4j) 二、日志级别​ 1、级别程度是：TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR ​ 2、默认级别debug，只能输出级别大于或者等于此级别的信息，例如设置为INFO，则只能输出INFO、WARN、ERROR的日志信息。","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Log","slug":"Log","permalink":"https://nty99.gitee.io/tags/Log/"}]},{"title":"Ribbon","slug":"Ribbon","date":"2022-09-11T14:58:20.000Z","updated":"2022-10-05T15:23:03.596Z","comments":true,"path":"2022/09/11/ribbon/","link":"","permalink":"https://nty99.gitee.io/2022/09/11/ribbon/","excerpt":"","text":"一、Ribbon1、原理​ 1、发送请求被RibbonLoadBalancerClient拦截 ​ 2、获取请求中的服务名称 ​ 3、交给DynamicServerListLoadBalancer去注册中心拉去服务地址 ​ 4、返回服务列表给DynamicServerListLoadBalancer，匹配IRule定义的策略选择服务 ​ 5、用服务地址替换原来的地址发送请求 2、负载均衡策略​ 1、Bean方式，全局 @Bean public IRule randomRule(){ return new RandomRule(); } ​ 2、配置方式，局部、灵活 服务名称: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 3、Ribbon加载方式​ 默认采用懒加载所以第一次调用时间会长，可以配置采用饥饿加载，服务启动就把服务地址缓存在DynamicServerListLoadBalancer ribbon: eager-load: enabled: true # 开启饥饿加载 clients: # 指定饥饿加载的服务名称 - userservice","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Ribbon","slug":"Ribbon","permalink":"https://nty99.gitee.io/tags/Ribbon/"}]},{"title":"Nginx","slug":"Nginx","date":"2022-09-11T14:57:58.000Z","updated":"2022-10-05T15:22:43.309Z","comments":true,"path":"2022/09/11/nginx/","link":"","permalink":"https://nty99.gitee.io/2022/09/11/nginx/","excerpt":"","text":"一、代理配置​ 在nginx中配置proxy_pass时，如果在proxy_pass后面的url加/，相当于是绝对根路径，则nginx不会把location中匹配的路径部分代理走。如果没有/，则会把匹配的路径部分给代理走。比如访问：127.0.0.1/a/index.html。 location /a { proxy_pass http://127.0.0.1/ } 相当于http://127.0.0.1/index.html location /a { proxy_pass http://127.0.0.1 } 相当于http://127.0.0.1/a/index.html location /a { proxy_pass http://127.0.0.1/linux/ } 相当于http://127.0.0.1/linux/index.html location /a { proxy_pass http://127.0.0.1/linux } 相当于http://127.0.0.1/linuxindex.html","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://nty99.gitee.io/tags/Nginx/"}]},{"title":"Nacos","slug":"Nacos","date":"2022-09-11T14:57:52.000Z","updated":"2022-10-05T15:22:24.890Z","comments":true,"path":"2022/09/11/nacos/","link":"","permalink":"https://nty99.gitee.io/2022/09/11/nacos/","excerpt":"","text":"一、Nacos1、负载均衡策略：配置同集群访问后，优先随机访问同集群，当本集群的实例宕机了再访问其他集群的实例，此时会有警告产生，跨集群访问。 2、服务默认为临时实例，配置服务为非临时实例时，Nacos主动询问实例是否健康，若服务宕机后会立即pull给消费者，且Nacos不会剔除服务。 3、配置namespace环境隔离，则不同环境的服务不能通信。","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://nty99.gitee.io/tags/Nacos/"}]},{"title":"Mybatis相关知识点","slug":"Mybatis","date":"2022-09-11T14:57:46.000Z","updated":"2022-10-05T15:22:36.986Z","comments":true,"path":"2022/09/11/mybatis/","link":"","permalink":"https://nty99.gitee.io/2022/09/11/mybatis/","excerpt":"","text":"一、#和$区别​ 1、使用#{param}，是经过预编译的，会将传递过来的参数换转换成”param”。 ​ 2、使用${param}，是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入问题。 二、一、二级缓存​ 1、spring结合mybatis后，在未开启事物的情况之下，每次查询，spring都会关闭旧的sqlSession而创建新的sqlSession,因此此时的一级缓存是没有启作用的。在开启事物的情况之下，spring使用threadLocal获取当前资源绑定同一个sqlSession，因此此时一级缓存是有效的。 ​ 2、查出的数据都会被默认先放在一级缓存中。只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中。 ​ 3、一级缓存：sqlSession级别的缓存。（相当于一个方法内的缓存）每一次会话都对应自己的一级缓存，作用范围比较小，一旦会话关闭就查询不到了；一级缓存默认是一直开启的，是SqlSession级别的一个Map；与数据库同一次会话期间查询到的数据会放在本地缓存中。 ​ 4、基于namespace名称空间级别的缓存：一个namespace对应一个二级缓存，一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中。 ​ 5、如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容。 三、二级缓存开启​ 1、开启全局二级缓存配置 &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; ​ 2、去mapper.xml中配置使用二级缓存 &lt;cache&gt;&lt;/cache&gt; ​ 3、我们的POJO需要实现序列化接口 四、缓存选择顺序​ 1、先判断二级缓存是否开启，如果没开启，再判断一级缓存是否开启，如果没开启，直接查数据库。 ​ 2、如果一级缓存关闭，即使二级缓存开启也没有数据，因为二级缓存的数据从一级缓存获取。 ​ 3、一般不会关闭一级缓存，二级缓存默认不开启。 ​ 4、如果二级缓存关闭，直接判断一级缓存是否有数据，如果没有就查数据库。 ​ 5、如果二级缓存开启，先判断二级缓存有没有数据，如果有就直接返回；如果没有，就查询一级缓存，如果有就返回，没有就查询数据库。 五、一级缓存失效原因​ 1、不同的会话对象 ​ 2、会话对象相同，查询不在缓存中的内容 ​ 3、两次查询期间进行了增删改的操作 ​ 4、会话完成后手动清空缓存 问题​ 1、mapper层使用Integer、String等做参数时候，出现There is no getter for property named ‘xxx’ in ‘class java.lang.String’ ​ （1）在mapper层使用@Param映射 ​ （2）使用_parameter、value做参数 &lt;select id=\"test\" resultType=\"java.lang.Integer\"&gt; SELECT ... &lt;!--字符串比较加toString()-&gt; &lt;choose&gt; &lt;when test=\"param == '0'.toString()\"&gt; ... &lt;/when&gt; ------- &lt;when test=\"_parameter == '0'.toString()\"&gt; ... &lt;/when&gt; &lt;/choose&gt; &lt;/select&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://nty99.gitee.io/tags/Mybatis/"}]},{"title":"Linux命令","slug":"Linux命令","date":"2022-08-23T06:53:03.000Z","updated":"2022-10-05T15:21:57.381Z","comments":true,"path":"2022/08/23/linux/","link":"","permalink":"https://nty99.gitee.io/2022/08/23/linux/","excerpt":"","text":"一、特殊符号1、&amp; 和 &amp;&amp;​ （1）&amp; 表示在后台执行任务，关闭终端后，进程消失。 ​ （2）&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令。 2、| 和 ||​ （1）| 表示管道，上一条命令的输出，作为下一条命令参数(输入)。 ​ （2）|| 表示上一条命令执行失败后，才执行下一条命令。 3、&gt; 和 &gt;&gt;​ （1）&gt; 表示stdout标准输出信息重定向输出，覆盖写。 ​ （2）&gt;&gt; 表示内容追加写。 4、&amp;&gt; 、2&gt;&amp;1 和 2&gt;1​ （1）&amp;&gt; 表示stdout标准输出和stderr错误输出信息，重定向输出，覆盖写。 ​ （2）2&gt;&amp;1 表示把标准错误的输出重定向到标准输出1，&amp;指示不要把1当做普通文件，而是fd=1即标准输出处理。 ​ （3）2&gt;1 表示把标准错误的输出重定向到1，但这个1不是标准输出，而是一个名为1的文件。 ​ 5、重定向设备代码 ​ （1）空设备文件/dev/null，表示把所有写入的东西通通扔掉。 ​ （2）标准输入(stdin) 代码为0，实际映射关系：/dev/stdin -&gt; /proc/self/fd/0。 ​ （3）标准输出(stdout)代码为1，实际映射关系：/dev/stdout -&gt; /proc/self/fd/1。 ​ （4）标准错误输出(stderr)代码为2，实际映射关系：/dev/stderr -&gt;/pro/self/fd/2。 二、压缩解压#将所有jpg的文件压缩成all.tar.gz tar -czf all.tar.gz *.jpg #解压all.tar.gz文件 tar -xzf all.tar.gz 三、进程1、查找进程#显示所有的进程 ps -A #显示指定用户的进程（这里选定root用户） ps -u root #查找相关进程，最常用 ps -ef | grep php #将目前属于您自己这次登入的 PID 与相关信息列示出來 ps -l 2、杀死进程#正常停止该进程 = kill -15 pid = kill -s TERM kill pid #强制杀死该进程 = kill -s SIGKILL pid kill -9 pid #重启该进程 = kill -s SIGHUP pid kill -1 pid 3、改变进程状态1、基本命令#查看作业 jobs -l #将后台中的命令调至前台继续运行，jobnum指通过jobs命令显示的任务编号 fg % jobnum #中断该进程 Ctrl + c #将一个正在前台执行的命令放到后台，并且处于暂停状态 Ctrl + z #将一个在后台暂停的命令，变成在后台继续执行 bg % jobnum #通过作业编号杀死进程 kill % jobnum 2、详解​ （1）shell：命令解释器，其实就是一个脚本语言解释器，有很多种(bash,ash,tcsh等)，最常用的是bash。 ​ （2）job：是相对shell 来说的，在shell中执行一条命令，实际上就是提交了一个job，只不过有的job需要运行很长时间，有的job很快就结束。所以作业是shell里面的一个概念，jobs命令只能查看当前shell自己的job，不同的shell 之间相互隔离。我们在shell里执行一条命令的时候就开启了一个作业，一个作业对应着系统中的一个进程组，如果作业中的某个进程又创建了子进程，则子进程不属于作业。 4、定时执行#参数详解 -n 指定间隔的时间，默认单位秒，不指定间隔时间则默认2秒执行一次 -d 会高亮显示变化的区域 -t 会关闭watch命令在顶部的时间间隔 #每10s在后台执行一次test.sh脚本 watch -n 10 bash test.sh &amp; #每隔一秒高亮显示http链接数的变化情况,后面接的命令若带有管道符，需要加''将命令区域归整 watch -n 1 -d 'pstree|grep http' 5、后台挂载1、基本命令#让程序始终在后台执行，即使关闭当前的终端也执行 nohup ./test.sh &gt; r.log 2&gt;&amp;1 &amp; 运行jar包，并且置于后台执行，执行的日志重定向到当前默认的log.txt文件中 java -jar test.jar &gt; log.txt &amp; 2、详解​ nohup命令，在默认情况下(非重定向时)，会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。nohup不挂断地运行命令，正常退出终端不会影响程序的运行，&amp; 让命令在后台执行，关闭终端后，进程消失。 3、原理​ （1）nohup ./start.sh时候，关闭shell，此时进程还存在(对SIGHUP信号免疫)，但是， 要注意， 如果你直接在shell中用Ctrl C, 那么start.sh进程也是会消失的(因为对SIGINT信号不免疫)。 ​ （2）&amp;的意思是在后台运行，什么意思呢?意思是说，当你在执行 ./start.sh &amp; 的时候，即使你用Ctrl C，那么start.sh照样运行(因为对SIGINT信号免疫)。但是要注意，如果你直接关掉shell后， 那么，start.sh进程同样消失。 可见，&amp;的后台并不硬（因为对SIGHUP信号不免疫)。 三、网络#显示详细的网络状况 netstat -a #显示TCP端口号的使用情况，mac中使用netstat -p tcp netstat -apt #显示网卡列表 netstat -i #显示网络统计信息 netstat -s #查找端口占用情况 netstat -apt | grep 8080 四、查看日志1、cat​ 由第一行开始显示文件所有内容。 ​ 1、参数说明 -A : 相当于-vET 的整合参数，可列出一些特殊字符，而不是空白而已 -b : 列出行号，仅针对非空白行做行号显示，空白行不标行号 -E : 将结尾的断行字符$显示出来 -n : 打印行号，连同空白行也会有行号，与-b的参数不同 ​ 2、适用场景 ​ （1）cat是Concatenate的缩写，主要功能是将一个文件的内容连续显示在屏幕上面。 ​ （2）一般文件内容行数较少时，如40行之内，适合用cat。 ​ （3）如果是一般的DOS文件时，就需要特别留意一些奇怪的符号，例如断行与[Tab]等，要显示出来，就得加入-a之类的参数了。 2、tac​ 从最后一行开始显示，可以看出tac是cat的倒写形式。 ​ 1、参数说明 -b, --before : 在之前而不是之后连接分隔符。 -r, --regex : 将分隔符作为基础正则表达式（BRE）处理。 -s, --separator=STRING : 使用STRING作为分隔符代替默认的换行符。 --help : 显示帮助信息并退出。 --version : 显示版本信息并退出。 ​ 2、适用场景 ​ tac 的功能跟cat相反，cat是由第一行到最后一行连续显示在屏幕上，而tac则是由最后一行到第一行反向在屏幕上显示出来。 3、head​ 显示文件开头的内容，以行为单位，默认文件开头的前10行。 ​ 1、参数说明 -n : 显示的行数，如 -10 显示10行 -q : 隐藏文件名 -v : 显示文件名 -c : 显示字节数，如 -c1024 显示1024个字节 #例如 4、tail​ 查看文件的内容，也是以行为单位，默认10行，从尾往前看。监听Java动态日志时，一般跟-f参数配合使用。 ​ 1、参数说明 -f : 循环读取 -q : 不显示处理信息 -v : 显示详细的处理信息 -c : 显示的字节数 -n : 显示文件的尾部 n 行内容 ​ 2、适用场景 ​ tail -f用来动态监听Java日志，开发联调经常使用到，它一般跟grep 一起搭档使用。 5、more​ 一页一页地显示文件内容，每页显示条数根据当前窗口决定。 ​ 1、参数说明 -num : 一次显示的行数，如 -10 表示每页显示10行 +num : 从第 num 行开始显示 -p : 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容 -c : 跟 -p 相似，不同的是先显示内容再清除其他旧资料 -s : 当遇到有连续两行以上的空白行，就代换为一行的空白行 +/pattern : 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示 -u : 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同） fileNames : 欲显示内容的文档，可为复数个数 ​ 2、阅读后常用操作 ​ 按q离开，按Enter往下滚动一行，按空格键往下翻页，按b往回翻页，以及/字符串搜索功能。更多操作如下： 空格键 : 代表往下翻一页。 Enter : 代表往下滚动一行。 /字符串 : 代表在这个显示的内容当中，向下查询字符串这个关键字，重复查询同一个字符串，可以直接按下n。 :f : 立刻显示出文件名以及目前显示的行数。 q : 代表立刻离开more，不再显示该文件内容。 b : 代表往回翻页，不过这操作只对文件有用，对管道无用。 ​ 3、适用场景 ​ more使用日志比较大的文件查看，可以一页一页查看，不会让前面的数据看不到。 6、less​ less 与 more 类似，但less的用法比起more又更加有弹性，每页显示条数根据当前窗口决定。 ​ 1、参数说明 -b : 设置缓冲区的大小，如-b1024 -e : 当文件显示结束后，自动离开 -f : 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -F : 和tail -f效果类似 -g : 只标志最后搜索的关键词 -i : 忽略搜索时的大小写 -m : 显示类似more命令的百分比 -N : 显示行号 ​ 2、阅读后常用操作 空格键 : 往下翻动一页 [pagedown] : 向下翻动一页 [pageup] : 向上翻动一页 Enter : 代表往下滚动一行 /字符串 : 向下搜索\"字符串\"的功能 ?字符串 : 向上搜索\"字符串\"的功能 g : 移动到第一行 G : 移动到最后一行 m : 标记，输入一个字符 ’ : 回到标记处，例如输入mk标记，输入'k回到标记处 n : 重复前一个搜索（与 / 或 ? 有关） N : 反向重复前一个搜索（与 / 或 ? 有关） q : 离开less这个程序 ​ 3、适用场景 ​ less适合日志比较大的文件查看，可以一页一页查看，并且比more更灵活，也可以动态查看日志，一般用它查看Java日志。 ​ 4、常用命令 #ps查看进程信息并通过less分页显示 ps -ef |less #查看两个文件，输入:n，切换到b.text，再输入:p返回到a.text less a.text b.text 五、性能查看​ 性能测试时，通常用top命令观察cpu、内存使用情况。free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。 1、top基本信息#输入top命令后，有如下信息 [root@iZbp1990f69tlsyjyxqqs8Z /]# top top - 22:26:36 up 392 days, 7:01, 1 user, load average: 0.12, 0.10, 0.08 Tasks: 92 total, 1 running, 91 sleeping, 0 stopped, 0 zombie %Cpu(s): 1.3 us, 1.0 sy, 0.0 ni, 97.6 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 1776404 total, 81040 free, 1342048 used, 353316 buff/cache KiB Swap: 0 total, 0 free, 0 used. 255236 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 30211 root 10 -10 148920 21816 6776 S 4.3 1.2 1258:22 AliYunDun 20206 admin 20 0 1116532 243096 8868 S 0.7 13.7 11:43.36 node 1256 root 20 0 1318628 42752 1660 S 0.3 2.4 100:13.44 dockerd 19725 root 10 -10 436912 920 320 S 0.3 0.1 55:57.24 AliSecGuard 19922 admin 20 0 3265824 881100 13440 S 0.3 49.6 31:29.62 java ​ （1）第一行：当前时间22:26:36，系统运行天数392，当前1个用户登录，系统平均负载压力情况为0.12(1min的平均负载压力)、0.10(5min的平均负载压力)、0.0.8(15min的平均负载压力)。注：load average：每隔5s检查一次活跃的进程数，然后按特定算法计算出来的。一般当这个数值除以CPU的核数得到的值大于3~5时，就标明系统的负载压力已经很高了。 ​ （2）第二行：显示的是任务信息，总共92个进程，1个进程正在执行，91个进程正在休眠，0个进程停止，0个进程假死。 ​ （3）第三行：显示的是CPU运行信息，1.3us表示用户模式下CPU占比为1.3%，1.0sy标识系统模式下CPU占比1.0%，0.0ni表示改变过优先级的进程的CPU占比为0.0%，97.6id表示空闲状态的CPU占比为97.6%，0.0wa表示因为I/O等待造成的CPU占用比为0.0%，0.0st表示CPU等待虚拟机调度的时间占比，这个指标一般在虚拟机中才有，在物理机中该值一般为0。 ​ （4）第四行：显示的是内存信息，1776404 total显示的是物理内存总量，1342048 used显示已使用的物理内存，81040 free表示空闲物理内存，353316 buffers 表示用于缓存内存大小，以上单位都是kb。 ​ （5）第五行：显示虚拟内存使用信息，0 total 表示虚拟内存空间总大小，0 used 表示虚拟内存使用大小，0 free 表示空闲虚拟内存，255236 avail Mem 表示还可以被使用的物理内存大小，cached Mem表示缓存虚拟内存，以上单位都是kb。 ​ （6）第六行： PID USER PR NI VIRT RES 进程号 进程的持有用户 进程运行的优先级，值越小优先级越高，会越早获取CPU的执行权 进程的nice值，表示进程可被执行的优先级的修正数值 进程使用虚拟内存，单位kb 常驻内存，单位kb SHR S %CPU %MEM TIME+ COMMAND 进程使用的共享内存，单位kb 进程运行状态。 进行运行时CPU的占用比 进程使用的内存占用比 进程占用的CPU总时长 进程名 2、top常用命令​ （1）查看指定进程的信息 [root@iZbp1990f69tlsyjyxqqs8Z /]# top -p 19922 top - 22:57:53 up 392 days, 7:32, 1 user, load average: 0.10, 0.09, 0.12 Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie %Cpu(s): 1.0 us, 1.0 sy, 0.0 ni, 98.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 1776404 total, 80424 free, 1344592 used, 351388 buff/cache KiB Swap: 0 total, 0 free, 0 used. 253116 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 19922 admin 20 0 3265896 881004 13280 S 0.0 49.6 32:04.95 java ​ （2）查看指定进程的所有线程的信息 [root@iZbp1990f69tlsyjyxqqs8Z /]# top -H -p 19922 top - 23:03:23 up 392 days, 7:38, 1 user, load average: 0.09, 0.13, 0.13 Threads: 72 total, 0 running, 72 sleeping, 0 stopped, 0 zombie %Cpu(s): 2.0 us, 1.0 sy, 0.0 ni, 97.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 1776404 total, 79864 free, 1343716 used, 352824 buff/cache KiB Swap: 0 total, 0 free, 0 used. 253960 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 21146 admin 20 0 3265912 880832 13108 S 0.7 49.6 3:01.67 elasticsearch[0 21161 admin 20 0 3265912 880832 13108 S 0.3 49.6 2:13.15 elasticsearch[0 19922 admin 20 0 3265912 880832 13108 S 0.0 49.6 0:00.01 java 20076 admin 20 0 3265912 880832 13108 S 0.0 49.6 0:11.33 java 3、free基本信息[root@iZbp1990f69tlsyjyxqqs8Z /]# free total used free shared buff/cache available Mem: 1776404 1343792 78148 608 354464 253664 Swap: 0 0 0 ​ （1）第一行：Mem表示物理内存统计，total表示总物理内存的大小，used表示已使用多少，free表示可用内存多少，shared表示多个进程共享的内存总额，buffers/cached表示磁盘缓存的大小。 ​ （2）第二行：Swap表示硬盘上的交换分区的使用情况。 4、free常用命令​ （1）基本查看 #以Byte、KB、MB、G、合适来显示内存使用情况 free -b | -k | -m | -g | -h #以总和的形式查询内存的使用信息 free -m -t ​ （2）周期性的查询内存使用信息 #每10s 执行一次命令 free -s 10 ​ （3）free 与 available区别 ​ 在 free 命令的输出中，有一个 free 列，同时还有一个 available 列。这二者到底有何区别？free 是真正尚未被使用的物理内存数量。至于 available 就比较有意思了，它是从应用程序的角度看到的可用内存数量。Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，available = free + buffer + cache。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。 六、防火墙1、防火墙配置#设置开机启用防火墙： systemctl enable firewalld.service #设置开机禁用防火墙 systemctl disable firewalld.service #启动防火墙 systemctl start firewalld #重启防火墙服务 systemctl restart firewalld #关闭防火墙 systemctl stop firewalld #检查防火墙状态 systemctl status firewalld 2、端口配置​ 使用firewall配置策略有两种模式：运行时模式(runtime)、永久模式(permanent)。运行时模式又称为当前生效模式，而且随着系统的重启会失效，它是默认的模式。而如果需要配置永久生效，就需要添加–permanent 参数。主要注意的是永久模式配置的策略只有重启之后才能自动生效，如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload 命令。 #查看防火墙状态 firewall-cmd --state #重新加载配置 firewall-cmd --reload #查看开放的端口 firewall-cmd --list-ports #开启防火墙端口 firewall-cmd --zone=public --add-port=9200/tcp --permanent #开启防火墙多个端口 firewall-cmd --zone=public --add-port=80-90/tcp --permanent #移除防火墙端口 firewall-cmd --zone=public --remove-port=80/tcp --permanent ​ 3、防火墙配置文件 ​ 配置文件说明:firewalld 存放配置文件有两个目录，/usr/lib/firewalld/和/etc/firewalld/。前者存放了一些默认的文件，后者主要是存放用户自定义的数据，所以我们添加的service或者rule都在后者下面进行。 [root@iZbp1990f69tlsyjyxqqs8Z ~]# ls /usr/lib/firewalld/ helpers icmptypes ipsets services xmlschema zones [root@iZbp1990f69tlsyjyxqqs8Z ~]# ls /etc/firewalld/ firewalld.conf helpers icmptypes ipsets lockdown-whitelist.xml services zones services : 存储服务数据，就是一组定义好的规则。 zones : 存储区域规则。 firewalld.conf : 默认配置文件，可以设置默认使用的区域，默认区域为public，对应zones目录下的public.xml。 ​ 4、其它常用配置 #查看当前使用的区域 firewall-cmd --get-default-zone #查看当前使用的区域是否允许请求ssh和https协议的流量 firewall-cmd --zone=public --query-service=ssh firewall-cmd --zone=public --query-service=https #设置https协议流量为永久允许并立即生效 firewall-cmd --zone=public --add-service=https --permanent firewall-cmd --reload #允许8080和8081端口流量，仅限当前生效 firewall-cmd --zone=public --add-port=8080-8081/tcp 七、拓展知识点1、进程状态​ 常见的五种如下，所有的状态如下面表格。 ​ （1）运行(正在运行或在运行队列中等待) ，状态码D。 ​ （2）中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)，状态码S。 ​ （3）不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) ，状态码D。 ​ （4）僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)，状态码Z 。 ​ （5）停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ，状态码T。 状态 D R S T Z 含义 无法中断的休眠状态 (通常 IO 的进程) 正在执行中 静止状态 暂停执行 不存在但暂时无法消除 状态 W &lt; N L 含义 没有足够的记忆体分页可分配 高优先序的行程 低优先序的行程 有记忆体分页分配并锁在记忆体内 2、进程详情信息​ ps是Process Status的缩写，用来列出系统中当前运行的那些进程。ps命令列出的是当前进程的快照，就是执行ps命令这个时刻的进程，可以使用top命令获取动态的进程信息。 USER PID %CPU %MEM VSZ RSS 进程拥有者 pid 占用的 CPU 使用率 占用的记忆体使用率 虚拟记忆体大小 占用的记忆体大小 TT STAT STARTED TIME COMMAND 终端的次要装置号码 该进程的状态 行程开始时间 执行的时间 所执行的指令 3、进程和作业的联系​ （1）shell：命令解释器，其实就是一个脚本语言解释器，有很多种(bash,ash,tcsh等),最常用的是bash。 ​ （2）job：是相对shell 来说的，在shell中执行一条命令，实际上就是提交了一个job，只不过有的job需要运行很长时间，有的job很快就结束。","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nty99.gitee.io/tags/Linux/"}]},{"title":"RabbitMQ","slug":"RabbitMQ","date":"2022-08-23T06:52:44.000Z","updated":"2022-10-05T15:22:57.008Z","comments":true,"path":"2022/08/23/mq/","link":"","permalink":"https://nty99.gitee.io/2022/08/23/mq/","excerpt":"","text":"一、工作模式 工作模式 Hello World Work queues Publish/Subscribe Routing Topics 工作类型 默认交换机 默认交换机 给所有绑定的队列发送消息，此时不用指定routingKey 给指定的routingKey发送消息 给匹配的路由发送消息","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"https://nty99.gitee.io/tags/MQ/"}]},{"title":"Docker相关知识点","slug":"Docker","date":"2022-08-23T06:52:35.000Z","updated":"2022-10-05T15:21:23.184Z","comments":true,"path":"2022/08/23/deploy/","link":"","permalink":"https://nty99.gitee.io/2022/08/23/deploy/","excerpt":"","text":"一、Docker常用命令docker pull 服务:tag 服务:版本（拉取服务，不加tag则默认最新版） docker images 查看镜像 docker save -o nginx.tar nginx:lastest 将nginx:latest镜像打包 docker load -i nginx.tar 加载镜像 docker rmi 删除镜像 docker rm 删除容器 -f 删除运行的容器 docker ps 查看运行容器状态 -a 则查看所有容器状态 docker run --name 取名字 -p 80:80 -d 镜像 运行镜像，-p端口映射，-d后台运行 docker logs mn 查看mn容器的日志 -f 动态查看 docker exec -it mn bash 以bash命令进入mn容器 docker stop mn 停止mn容器 docker (un)pause （恢复）暂停镜像 docker restart mn 重启mn容器 二、Docker镜像结构1、镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。 2、镜像是分成结构、每一层称为一个Layer。 ​ （1）BaseImage层:包含基本的系统函数库、环境变量、文件系统 ​ （2）Entrypoint：入口，是镜像中应用启动的命令 ​ （3）其它：在BaseImage基础上添加依赖、安装程序、完成整改个应用的安装和配置","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"云原生","slug":"云原生","permalink":"https://nty99.gitee.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"}]},{"title":"数据库","slug":"数据库","date":"2022-08-23T06:52:23.000Z","updated":"2022-10-12T15:53:16.964Z","comments":true,"path":"2022/08/23/database/","link":"","permalink":"https://nty99.gitee.io/2022/08/23/database/","excerpt":"","text":"一、Mysql1、执行顺序​ 1、执行where xx对全表数据做筛选，返回第1个结果集 ​ 2、针对第1个结果集使用group by分组，返回第2个结果集 ​ 3、针对第2个结果集中的每1组数据执行select xx，有几组就执行几次，返回第3个结果集 ​ 4、针对第3个结集执行having xx进行筛选，返回第4个结果集 ​ 5、针对第4个结果集排序 ​ 6、完整顺序:from、join、where、group by、with、having、order 2、索引​ 1、数据结构 ​ （1）Innob主键索引是聚集索引方式，数据和索引都在同一个文件里面，主键索引叶子节点存储的是数据，二级索引即非聚簇索引叶子节点存储的是主键key，主索引叶子节点存储的是数据。 ​ （2）MyISAM 用的是非聚集索引方式，即数据和索引落在不同的两个文件上。MyISAM 在建表时以主键作为 KEY 来建立主索引B+树，树的叶子节点存的是对应数据的物理地址。我们拿到这个物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录了。 ​ 2、选择条件 ​ (1)较频繁的作为查询条件的字段应该创建索引 ​ (2)唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件 ​ (3)更新非常频繁的字段不适合创建索引 ​ 3、分类 ​ 1、聚簇索引：数据存储的一种方式，索引的顺序和数据记录的顺序一致 ​ 2、非聚簇索引：索引顺序和存储顺序无关 3、count​ 1、count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL。 ​ 2、count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL。 ​ 3、count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空(这里的空不是只空字符串或者0，而是表示null)的计数， 即某 个字段值为NULL时，不统计。 ​ 4、列名为主键，count(列名)会比count(1)快。 ​ 5、列名不为主键，count(1)会比count(列名)快。 ​ 6、如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)。 ​ 7、如果有主键，则 select count(主键)的执行效率是最优的。 ​ 8、如果表只有一个字段，则 select count(*)最优。 4、存储引擎​ 1、类型 ​ InnoDB、MyISAM ​ 2、区别 ​ （1）InnoDB 支持事务，MyISAM不支持事务。 ​ （2）InnoDB支持外键，MyISAM不支持。 ​ （3）InnoDB支持行锁和表锁，ISAM不支持行锁。 ​ （4）InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。 5、执行计划6、最左前缀原则​ 如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，遇到范围查询时候停止匹配。 7、优化器8、锁的分类和作用​ 1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 ​ 2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 ​ 3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 9、序列（1）创建 CREATE SEQUENCE SEQ_TEST minvalue 1 --最小值 nomaxvalue 100 --最大值 start with 1 --起始值 increment by 1 --增长基数 nocycle --不循环，一直增加 nocache; --不使用缓存 --插入数据示例 INSERT INTO TEST(ID,NAME) VALUES(SEQ_TEST.nextval,'abc') --修改序列 ALTER SEQUENCE TEST increment by -1 （2）修改 Tips​ 1、默认查询是不分大小写，若需要区分，可在建表时候指定，或者在查询时候在字段前面加上binary。 二、OracleTips​ 1、Oracle执行sql的的隐式转换 ​ 2、Oracle DROP误删表后恢复 ​ （1）SELECT * FROM USER_RECYCLEBIN ​ （2）FLASHBACK TABLE TABLE_NAME TO BEFORE DROP ​ 3、删除Table不进入Recycle的方法：DROP TABLE TABLE_NAME PURGE即永久删除 三、Redishash双链集合，set、zset、list单链集合 exists key 查看key是否存在 incr/decr key (key的值增加/减少1) incrby/decrby key n (key的值增加/减少n) 单个命令实现的所有Redis操作都是原子的，包括对更复杂数据结构的操作。因此，当您使用修改某些值的 Redis 命令时，您不必考虑并发访问。 set key value ex time 设置键的过期时间 ttl key 查看键的过期时间 -1 永久 -2 失效 20 20秒后失效 persist key 移除key的过期时间 列表：list llen key 查看列表长度 lpush / rpush key value（向列表头 / 尾插入信息） lrange key 0 -1 （遍历从头到尾的值） lange key 0 -2 （遍历从头到倒数第二个值） lpop / rpop 删除头 / 尾的key，并把删除的值返回 lpush / rpush key value1,value2 向列表插入多个值，返回列表长度 集合：set sadd key value... 向集合中添加一个或多个元素 smembers key 遍历集合元素 srem key value 删除指定元素，存在返回1，不存在返回0 sismember key value 查看值是否存在，存在返回1，不存在返回0 sunion key1 key2 组合多个集合并返回所有元素 spop key n 随机删除n个元素并返回，默认返回一个 srandmember key n 随机返回集合中的n个元素，不写默认返回一个 sdiff key1 key2返回两个集合的差别 集合：zset zadd key_namae score value... 向有序集合添加一个或多个值(可修改指定值的分数) zrange key_name start end 获取指定范围内按score排序的集合 zrange key start end withscores 打印所有的value，并带有分数 zscore key value 获取指定value的score 哈希：hash hset key filed filed 添加一个或多个键值对 hget key filed 获取某个键值对 hgetall key 获取所有键值对 hincrby key filed n 给字段key增加n个整数值 hdel key filed 删除字段的值 hlen、hkeys、hvals key 打印键值对长度、所有的key、所有的值 redis两种持久化方案： RDB: save 900 1 save 300 10 save 60 10000 （60秒后有10000条数据发生变化则进行持久化） AOF: 开启appendonly 为yes # appendfsync always （每次操作进行一次持久化） appendfsync everysec （每秒进行一次持久化） # appendfsync no 四、ES1、配置ES开发环境docker run -d \\ --name es \\ -e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" \\ -e \"discovery.type=single-node\" \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:7.12.1 docker run -d \\ --name kibana \\ -e ELASTICSEARCH_HOSTS=http://es:9200 \\ --network es-net \\ -p 5601:5601 \\ kibana:7.12.1 2、DSL语句​ 1、索引库操作 #查看索引库 GET /hotel #删除索引库 DELETE /hotel #修改索引库 只能增添字段 PUT /hotel/_mapping { \"properties\":{ \"age\":{ \"type\":\"integer\" } } } # 建立索引库hotel type数据类型 analyzer分词器 PUT /hotel { \"mappings\": { \"properties\": { \"id\":{ \"type\": \"keyword\" }, \"name\":{ \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"copy_to\": \"all\" }, \"address\":{ \"type\": \"text\" }, \"price\":{ \"type\": \"integer\" }, \"all\":{ \"type\": \"text\", \"analyzer\": \"ik_max_word\" } } } } ​ 2、文档操作 #新增文档id为1的数据 POST /hotel/_doc/1 { \"id\":\"1\", \"name\":\"test\", \"address\":\"test\", \"price\":11 } #查询id为1的数据 GET /hotel/_doc/1 #删除id为1的数据 DELETE /hotel/_doc/1 #修改数据 全量修改 如果数据不存在则创建 PUT /hotel/_doc/1 { \"id\":\"1\", \"name\":\"test\", \"address\":\"test\", \"price\":11 } #修改数据 增量修改字段 POST /hotel/_update/1 { \"doc\": { \"address\":\"杭州\", \"price\":10000000 } } ​ 3、查询操作 #全文搜索 GET /hotel/_search { \"query\":{ \"match_all\": {} } } #单字段查询 all 多个字段整合 GET /hotel/_search { \"query\":{ \"match\": { \"all\": \"如家商圈\" } } } #多字段查询 GET /hotel/_search { \"query\":{ \"multi_match\": { \"query\": \"如家商圈\", \"fields\": [\"brand\",\"name\",\"business\"] } } } #精确查询 GET /hotel/_search { \"query\": { \"term\": { \"city\": { \"value\": \"上海\" } } } } #精确查询 范围查询 带e表示包含等于 GET /hotel/_search { \"query\": { \"range\": { \"price\": { \"gte\": 1000, \"lte\": 2000 } } } } #位置查询 geo_distance和geo_bounding_box GET /hotel/_search { \"query\": { \"geo_distance\": { \"distance\":\"10km\", \"location\":\"31.20, 121.30\" } } } #function_score查询 会修改最后得分 query_score和function_score来决定分数 GET /hotel/_search { \"query\": { \"function_score\": { \"query\": { \"match\": { \"name\": \"酒店\" } }, \"functions\": [ { \"filter\": { \"term\": { \"brand\": \"7天酒店\" } }, \"weight\": 10 } ], \"boost_mode\": \"sum\" } } } #bool查询 must_not和filter不会修改算分 GET /hotel/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"name\": \"如家\" } } ], \"must_not\": [ { \"range\": { \"price\": { \"gt\": 500 } } } ], \"filter\": [ { \"geo_distance\": { \"distance\": \"10km\", \"location\": { \"lat\": 39.945106, \"lon\": 116.353827 } } } ] } } } #sort排序 会放弃打分 GET /hotel/_search { \"query\": { \"match_all\": {} }, \"sort\": [ { \"score\": \"asc\" }, { \"price\": \"desc\" } ] } #sort排序 按地理位置排序 GET /hotel/_search { \"query\": { \"match_all\": {} }, \"sort\": [ { \"_geo_distance\": { \"location\": \"10.10,10.10\", \"order\": \"asc\", \"unit\": \"km\" } } ] } #分页查询 结果集(from+size)不能超过10000 还可以写成search after(需排序,记录上次查询的最后一个文档,查询下一页数据) GET /hotel/_search { \"query\": { \"match_all\": {} }, \"sort\": [ { \"price\": \"desc\" } ], \"from\": 0, \"size\": 10 } #高亮 GET /hotel/_search { \"query\": { \"match\": { \"all\": \"如家\" } }, \"highlight\": { \"fields\": { \"name\": { \"require_field_match\": \"false\" } } } } ​ 4、聚合查询 #聚合查询bucket 200元以下的酒店按品牌分组后的数量升序展示10条数据 GET /hotel/_search { \"query\": { \"range\": { \"price\": { \"lte\": 200 } } }, \"size\": 0, \"aggs\": { \"brandAggs\": { \"terms\": { \"field\": \"brand\", \"size\": 10, \"order\": { \"_count\": \"asc\" } } } } } #聚合查询 bucket+metrics 对分组后的品牌按平均分进行降序排序 GET /hotel/_search { \"size\": 0, \"aggs\": { \"brandAggs\": { \"terms\": { \"field\": \"brand\", \"size\": 5, \"order\": { \"scoreAggs.avg\": \"desc\" } }, \"aggs\": { \"scoreAggs\": { \"stats\": { \"field\": \"score\" } } } } } } ​ 5、自定义分词器 #创建分词器和搜索分词器不能混用 因为有可能词汇汉字不一样但是拼音一样导致搜索结果达不到预期效果 PUT /test { \"settings\": { \"analysis\": { \"analyzer\": { \"my_analyzer\": { \"tokenizer\": \"ik_max_word\", \"filter\": \"py\" } }, \"filter\": { \"py\": { \"type\": \"pinyin\", \"keep_full_pinyin\": false, \"keep_joined_full_pinyin\": true, \"keep_original\": true, \"limit_first_letter_length\": 16, \"remove_duplicated_term\": true, \"none_chinese_pinyin_tokenize\": false } } } } }","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://nty99.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"框架","slug":"SpringBoot","date":"2022-08-23T06:52:10.000Z","updated":"2022-10-05T15:23:10.495Z","comments":true,"path":"2022/08/23/frame/","link":"","permalink":"https://nty99.gitee.io/2022/08/23/frame/","excerpt":"","text":"一、SpringBoot1、bean的生命周期​ 1、Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化。 ​ 2、Bean实例化后对将Bean的引入和值注入到Bean的属性中。 ​ 3、如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法。 ​ 4、如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入。 ​ 5、如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。 ​ 6、如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。 ​ 7、如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用。 ​ 8、如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。 ​ 9、此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。 ​ 10、如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。 2、SpringMVC的执行流程​ 1、用户发送请求至前端控制器DispatcherServlet。 ​ 2、DispatcherServlet收到请求调用处理器映射器HandlerMapping。 ​ 3、处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。 ​ 4、DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作。 ​ 5、执行处理器Handler(Controller，也叫页面控制器)。 ​ 6、Handler执行完成返回ModelAndView。 ​ 7、HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet。 ​ 8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ​ 9、ViewReslover解析后返回具体View。 ​ 10、DispatcherServlet对View进行渲染视图(即将模型数据model填充至视图中)。 ​ 11、DispatcherServlet响应用户。 3、SpringBoot配置优先级​ 1、配置优先级 ​ （1）命令行参数 ​ （2）来自 java:comp/env 的 JNDI 属性 ​ （3）Java 系统属性（System.getProperties()） ​ （4）操作系统环境变量 ​ （5）RandomValuePropertySource 配置的 random.* 属性值 ​ （6）配置文件（YAML文件、Properties 文件） ​ （7）@Configuration 注解类上的 @PropertySource 指定的配置文件 ​ （8）通过SpringApplication.setDefaultProperties 指定的默认属性 ​ 2、配置文件优先级 4、Gateway​ GatewayFilter Factories中有30种过滤器，spring gateway网关中过滤器执行顺序按照order的值执行，值越小，优先级越高globalFilter的order值由我们自己指定，defaultFilter和路由filter由spring声明式指定，如果值一样，则执行defaultFilter、路由filter、globalFilter。defaultFilter和路由filter类型是GatewayFilter，globalFilter经过GatewayFilterAdapter转换成GatewayFilter。 5、AOP​ 1、不存在环绕通知执行顺序： ​ before执行、目标方法执行、AfterThrow执行、After执行。 ​ 2、存在环绕通知@Around执行顺序： @Before(\"point()\") public void before(JoinPoint joinPoint){ System.out.println(\"2 before执行\"); } @After(\"point()\") public void after(JoinPoint joinPoint){ System.out.println(\"5 After执行\"); } @AfterReturning(\"point()\") public void afterReturning(JoinPoint joinPoint){ System.out.println(\"4 AfterReturning执行\"); } @AfterThrowing(pointcut = \"point()\") public void afterThrowing(JoinPoint joinPoint){ System.out.println(\"4 AfterThrow执行\"); } @Around(\"point()\") public Object test(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"1 around前执行\"); //3、目标方法执行 Controller层方法 //6、切点执行 Object proceed = joinPoint.proceed(); System.out.println(\"7 around后执行\"); return proceed; } 6、加载顺序​ 1、同一个类中加载顺序 ​ Constructor &gt;&gt; @Autowired &gt;&gt;@ PostConstruct&gt;&gt;@Bean，跟Bean生命周期有关。 ​ 2、@Order注解并不能改变Bean加载优先级，@Order注解用于设置装载到list中Bean的顺序，用于比较多的是： ​ （1）控制AOP的类的加载顺序，也就是被@Aspect标注的类 ​ （2）控制ApplicationListener实现类的加载顺序 ​ （3）控制CommandLineRunner实现类的加载顺序 ​ 3、@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder这三个注解是给Springboot自动配置类排序使用的，注意是自动配置类(META_INF下的spring.factories配置文件)，并非是普通的配置类。 ​ 4、@DependsOn注解可以用来控制bean的创建顺序，该注解用于声明当前bean依赖于另外一个bean。所依赖的bean会被容器确保在当前bean实例化之前被实例化。 ​ 5、在@Bean标注的方法上，如果你传入了参数，springboot会自动会为这个参数在spring上下文里寻找这个类型的引用。并先初始化这个类的实例。利用此特性，我们也可以控制bean的加载顺序。 7、约定大于配置​ 1、开发人员仅需规定应用中不符合约定的部分 ​ 2、在没有规定配置的地方，采用默认配置，以力求最简配置为核心思想总的来说，上面两条都遵循了推荐默认配置的思想。当存在特殊需求的时候，自定义配置即可。这样可以大大的减少配置工作，这就是所谓的“约定”。 8、校验​ 1、官方提供：@NotBlank、@Size等。tips(除了@NotNull、@NotBlank外，其它的不会对null进行校验) ​ 2、自定义: 需在自定义注解上使用元注解@Constraint(validatedBy = xxx.class)，xxx.class实现ConstraintValidator接口进行处理 9、条件注解​ 1、@ConditionalOnProperty两个属性matchIfMissing、havingValue ​ （1）没有havingValue属性时候，matchIfMissing为true时，配置文件缺少字段也会注入成功，为false时有配置信息则可以注入，没有则不会注入。 ​ （2）有havingValue时候，havingValue值必须和配置值相同才会注入成功，不管matchIfMissing的值。 10、依赖注入​ 1、通过构造方法注入 ​ （1）采用构造方法上带有@Autowired注解注入。 ​ （2）无@Autowired时候，若有无参构造则采用无参构造，无则采用其它构造方法。 ​ 2、Setter注入 ​ （1）在需要注入的setter方法上加@Autored、@Resource注解。 ​ （2）只要setter方法上有@Autored、@Resource注解则一定会执行此注入方式，不管有无构造注入、字段注入。 11、热部署​ JRebel &amp; XRebel 二、Spring1、容器接口​ （1）容器顶级父接口：BeanFactory规范容器中的对象是延时加载的。 ​ （2）ApplicationContext接口：规范容器中的bean对象时非延时加载的，即创建容器对象的时候就对bean对象进行初始化，并存到容器中。 2、核心对象​ 1、BeanDefinition：封装bean对象。 ​ 2、BeanDefinitionReader：解析配置文件的中的bean元素，封装成BeanDefinition对象。 ​ 3、BeanDefinitionRegistry：存储bean名称和对应的BeanDefinition对象，存储中Map里面。 3、创建容器​ ClassPathXmlApplicationContext对bean配置资源的载入从调用父类的refresh()方法开始。refresh()是模版方法，规定了IOC容器的启动流程，有些逻辑需要交给子类实现。","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nty99.gitee.io/tags/Spring/"}]},{"title":"Java知识点和面试题","slug":"基础","date":"2022-08-23T06:51:21.000Z","updated":"2022-10-05T15:21:00.186Z","comments":true,"path":"2022/08/23/base/","link":"","permalink":"https://nty99.gitee.io/2022/08/23/base/","excerpt":"","text":"一、HashMap1、常见Map比较​ 1、hashmap 线程不安全，只允许有一个key为null，允许多个value为null。 ​ 2、hashtable线程安全，用的是内置锁synchronized，不允许key或value为null。 ​ 3、linkedhashmap 能保留put 键值对的顺序。 ​ 4、treemap实现sortmap接口能默认对put的键值对进行key排序。 2、ConcurrentHashMap​ 1、concurentHashMap与hashmap本质上并没有什么区别，只是concurrenthashMap是线程安全的 ​ 2、jdk1.7 采用了Segment分段锁，锁住几个槽位。 ​ 3、jdk1.8则采用 Node +CAS+synchronized来保证并发安全，锁的粒度下降了。 3、hashmap是线程不安全​ 1、多线程下对hashmap进行添加，删除，修改都可能会造成数据覆盖。 ​ 2、jdk1.7扩容时容易导致死循环。 4、putIfAbsent​ 1、map.putIfAbsent(key,value)，如果map中存在这个key，则返回key对应的值，如果不存在则返回null然后将值插入进去。 二、比较器 Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。 三、引用四、Cookie和Session1、存储位置​ 1、cookie存储在客户端，session存储在服务器 2、生成方式​ 1、第一次访问服务端时候，会创建一个session对象，并指定id为Jsessionid（Tomcat），然后响应给客户端，后续访问cookie里携带Jsessionid，服务端识别，判断是不是上次会话，如果是则不会创建session对象。 五、线程1、进程、线程、协程2、线程的地址空间3、线程池的七个参数问题​ 1、ThreadLocal、ThreadLocalMap、Thread区别 ​ (1)ThreadLocal内部类ThreadLocalMap，ThreadLocalMap的内部类Entry，Entry存储的键是ThreadLocal，值是调用ThreadLocal的set方法设置的值Thread有个成员变量ThreadLocalMap， ThreadLocal.ThreadLocalMap threadLocals = null。 ​ 2、多线程哪些内存是共享的，哪些不是共享的 ​ (1)Java虚拟机在执行Java程序的时候会把它管理的内存划分为5个不同的区域，其中方法区和堆是线程共享的，而虚拟机栈、程序计数器、本地方法栈是线程不共享的。 ​ 3、一个线程能访问到另一个线程的局部变量吗 ​ 4、synchronized和volatile区别 六、Http1、三次握手​ 1、第一次握手：第一次握手是客户端发送同步报文到服务端，这个时候客户端是知道自己具备发送数据的能力的，但是不知道服务端是否有接收和发送数据的能力。 ​ 2、第二次握手：当服务端接收到同步报文后，回复确认同步报文，此时服务端是知道客户端具有发送报文的能力，并且知道自己具有接收和发送数据的能力，但是并不知道客户端是否有接收数据的能力。 ​ 3、第三次握手：当客户端收到服务端的确认报文后，知道服务端具备接收和发送数据的能力，但是此时服务端并不知道自己具有接收的能力，所以还需要发送一个确认报文，告知服务端自己是具有接收能力的。 2、四次挥手​ 1、第一次挥手客户端发起关闭连接的请求给服务端。 ​ 2、第二次挥手：服务端收到关闭请求的时候可能这个时候数据还没发送完，所以服务端会先回复一个确认报文，表示自己知道客户端想要关闭连接了，但是因为数据还没传输完，所以还需要等待。 ​ 3、第三次挥手：当数据传输完了，服务端会主动发送一个 FIN 报文，告诉客户端，表示数据已经发送完了，服务端这边准备关闭连接了。 ​ 4、第四次挥手：当客户端收到服务端的 FIN 报文过后，会回复一个 ACK 报文，告诉服务端自己`知道了，再等待一会就关闭连接。 3、Http状态码问题​ 1、为什么握手要三次，挥手却要四次呢 ​ 那是因为握手的时候并没有数据传输，所以服务端的 SYN 和 ACK 报文可以一起发送，但是挥手的时候有数据在传输，所以 ACK 和 FIN 报文不能同时发送，需要分两步，所以会比握手多一步。 ​ 2、为什么客户端在第四次挥手后还会等待 2MSL ​ 等待2MSL是因为保证服务端接收到了ACK报文，因为网络是复杂了，很有可能ACK报文丢失了，如果服务端没接收到ACK报文的话，会重新发送FIN报文，只有当客户端等待了2MSL都没有收到重发的FIN报文时就表示服务端是正常收到了ACK报文，那么这个时候客户端就可以关闭了。 ​ 3、浏览器输入一个url发生了什么 ​ 输入网址、解析域名、建立Tcp连接、发送请求报文、响应数据报文、关闭Tcp连接、渲染页面。 ​ 4、get和post区别 ​ (1)GET在浏览器回退时是无害的，而POST会再次提交请求数据 ​ (2)GET参数通过URL传递，POST放在Request body中 ​ (3)GET请求会被浏览器主动缓存，而POST不会，除非手动设置 ​ (4)GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 ​ (5)GET请求在URL中传送的参数是有长度限制的，而POST没有 ​ (6)最大区别，get请求发送一个tcp数据包，post请求发送两个tcp数据包 七、GC八、数据在内存中存放的位置九、BIO、NIO、AIO十、对称加密和非对称加密十一、final、finally、finalize1、final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，比如 String 类 2、final 的变量是不可以修改的；Java 里用 final 修饰符去修饰一个方法的唯一正确用途就是表达：这个方法原本是一个虚方法，现在通 过 final 来声明这个方法不允许在派生类中进一步被覆写（override）。 3、finally 是 Java 保证重点代码一定要被执行的一种机制。可以使用 try-finally 或者 try-catch-finally 来进行关闭资源、保证 unlock 锁等 动作。 4、finalize 是基础类 java.lang.Object 的一个方法，设计目的是保证对象在被垃圾收集前完成特定资源的回收。 5、finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated 6、final修饰的变量必须初始化赋值或者构造方法里面赋值 7、static final修饰的变量必须初始化赋值或者在静态代码块里面赋值 十二、访问修饰符1、public : 对所有类可见。使用对象：类、接口、变量、方法 2、protected: 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类） 3、default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 4、private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） 十三、枚举1、每个枚举 其实都是class，且所有的枚举值都是 public static final 的，可用javap xxx.class查看。 public enum Color{ RED, GREEN, BLUE; } 通过javap ./Color.class查看 public final class Color extends Enum&lt;Color&gt; { public static final Color RED; public static final Color GREEN; public static final Color BLUE; public static Color[] values(); public static Color valueOf(java.lang.String); static {}; } values(), ordinal()和valueOf()方法 enum 定义的枚举类默认继承了java.lang.Enum类，并实现了java.lang.Serializable和java.lang.Comparable两个接口。 values(), ordinal() 和 valueOf() 方法位于java.lang.Enum 类中： values()返回枚举类中所有的值。 ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。 valueOf()方法返回指定字符串值的枚举常量。 枚举类中的抽象方法实现，需要枚举类中的每个对象都对其进行实现。 十四、序列化十五、SPI、factories1、SPI介绍​ SPI（Service Provider Interface），是JDK内置的一种服务提供发现机制，可以用来启用框架扩展和替换组件。JDK的spi机制提供了 ServiceLoader 类用于加载、解析spi接口的配置文件，ServiceLoader实现了Iterable接口，可迭代，但只能以迭代器的方式进行操作。使用 hasNext() 时才会加载解析 META-INF/services 下对应的接口配置文件，使用 next() 时才会通过实现类的 Class 对象newInstance() 方法（实质是通过反射调用无参构造器）创建实例。 2、使用教程​ 在模块本身的resources下新建目录 META-INF/services，services目录下新建文件，以服务接口的全限定接口名作为文件名，文件中指定该服务接口要使用的具体实现类。 ServiceLoader.load(Class&lt;S&gt; service,ClassLoader loader) 3、Spring factories1、介绍​ factories可以看做是spring结合自身需要提供的一种spi机制，设计思想和jdk的spi机制差不多。factories机制在spring家族中广泛使用spring、springboot、springcloud中都大量使用了factories机制。spring体系的很多扩展配置都是通过spring.factories 指定的，比如应用初始化器 ApplicationContextInitializer、应用监听器ApplicationListener。注解本质是一种特殊接口，也可以用 factories 指定实现类，比如springboot中的 @EnableAutoConfiguration 注解就使用了factories指定要应用的实现类。 4、使用教程SpringFactoriesLoader.loadFactories(Class&lt;T&gt; factoryType, @Nullable ClassLoader classLoader) SpringFactoriesLoader.loadFactoryNames(Class&lt;T&gt; factoryType, @Nullable ClassLoader classLoader) 5、区别​ jdk的spi机制，一个配置文件只能指定一个接口要使用的实现类；spring的factories机制，一个配置文件可以指定多个接口要使用的实现类。 十六、数据类型1、基本类型(四类八种) ​ 1、byte：占一个字节，一个字节占八位，所以范围按2*位算，例如byte最小值-2^7，最大值2^7-1 ​ 2、short：两个字节 ​ 3、int：四个字节 ​ 4、long：八个字节 ​ 5、float：四个字节，使用4字节存储，精度可以精确到小数点后7位有效数字，在多数情况下，float类型精度很难满足需要。 ​ 6、double：八个字节，采用双精度存储，精度是float的2倍，绝大部分应用程序采用float类型。 ​ 7、char：UTF-8编码，一个字符占两个字节，GBK编码，一个字符占三个字节 ​ (1)example：字节和字符转换 byte a = 97; System.out.println((char)a); // a System.out.println(byte('a')); // 97 ​ 8、boolean：Java虚拟机规范给出4个字节，1个字节、4个字节都是有可能的。这其实是运算效率和存储空间之间的博弈，两者都⾮常的重要。 2、引用类型 十七、多肽public class Dad{ public String name = \"父\"; public int age; public String getName(){ return name; } public void printName(){ System.out.println(\"父类\"); } public void ownName(){ System.out.println(\"名称\"+name); } public int getNum(){ return getI()+10; } public int getI(){ return 10; } } public class Son extends Dad{ public String name = \"子\"; public String getName(){ return name; } @Override public void printName(){ System.out.println(\"子类\"); } @Override public void ownName(){ System.out.println(\"名称\"+name); } public int getI(){ return 20; } } Dad d = new Son(); d.printName(); //输出子类 System.out.println(d.name); //输出父 System.out.println(d.getName()); //输出子 System.out.println(d.ownName()); //输出名称子 System.out.println(d.getNum()); //输出30 ​ （1）多肽写法，对象只能调用父类中存在的方法、变量。若子类重写方法则调用子类的方法。 ​ （2）d对象只能调用父类中的方法，如果子类中重写过该方法，则调用子类的方法。 ​ （3）子类成员变量和父类相同时，d.name输出父类定义的名称，d.getName()优先输出子类的名称，因为getName()方法重写了。 ​ （4）d.ownName()输出名称子，方法中的name优先选择自己类中的变量。 ​ （5）d.getNum()输出30，先调用父类getNum()，然后调用子类getI()。 十八、修饰符代表的数字 修饰符 public private protected static final synchronized 值 1 2 4 8 16 32 修饰符 volatile transient native interface abstract strict 值 64 128 256 512 1024 2048 ​ 通过反射获取的单个变量、方法、构造器，可以调用getModifiers()返回修饰符表示的值，针对单个修饰符可以通过 &amp; 来判断修饰符类型，如果存在多个修饰符则值表示各个修饰符相加。 十九、位运算符​ 1、异或 ^ ：两个二进制数同一位上数值不同则为1，反之为0。 ​ 2、或 |：两个二进制数同一位上数值有1则1，反之为0。 ​ 3、与 &amp;：两个二进制数同一位上数值都为1则1，反之为0。 ​ 4、左移运算符： ​ 5、又移运算符： ​ 6、无符号又移运算符： 问题","categories":[{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java Base","slug":"Java-Base","permalink":"https://nty99.gitee.io/tags/Java-Base/"}]}],"categories":[{"name":"生活","slug":"生活","permalink":"https://nty99.gitee.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"技术","slug":"技术","permalink":"https://nty99.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"aa","slug":"aa","permalink":"https://nty99.gitee.io/tags/aa/"},{"name":"算法","slug":"算法","permalink":"https://nty99.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"项目管理","slug":"项目管理","permalink":"https://nty99.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"VCS","slug":"VCS","permalink":"https://nty99.gitee.io/tags/VCS/"},{"name":"设计模式","slug":"设计模式","permalink":"https://nty99.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Log","slug":"Log","permalink":"https://nty99.gitee.io/tags/Log/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://nty99.gitee.io/tags/Ribbon/"},{"name":"Nginx","slug":"Nginx","permalink":"https://nty99.gitee.io/tags/Nginx/"},{"name":"Nacos","slug":"Nacos","permalink":"https://nty99.gitee.io/tags/Nacos/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://nty99.gitee.io/tags/Mybatis/"},{"name":"Linux","slug":"Linux","permalink":"https://nty99.gitee.io/tags/Linux/"},{"name":"MQ","slug":"MQ","permalink":"https://nty99.gitee.io/tags/MQ/"},{"name":"云原生","slug":"云原生","permalink":"https://nty99.gitee.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"},{"name":"数据库","slug":"数据库","permalink":"https://nty99.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Spring","slug":"Spring","permalink":"https://nty99.gitee.io/tags/Spring/"},{"name":"Java Base","slug":"Java-Base","permalink":"https://nty99.gitee.io/tags/Java-Base/"}]}