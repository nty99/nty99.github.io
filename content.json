{"meta":{"title":"我的博客","subtitle":"主题","description":"描述","author":"nty","url":"http://nty99.gitee.io","root":"/"},"pages":[{"title":"404","date":"2022-08-26T08:27:15.000Z","updated":"2022-08-26T08:57:11.184Z","comments":true,"path":"404/index.html","permalink":"http://nty99.gitee.io/404/","excerpt":"","text":""},{"title":"分类","date":"2022-08-21T15:48:43.000Z","updated":"2022-08-22T02:58:15.901Z","comments":true,"path":"categories/index.html","permalink":"http://nty99.gitee.io/categories/","excerpt":"","text":""},{"title":"关于","date":"2022-08-22T01:50:10.000Z","updated":"2022-08-26T08:24:52.458Z","comments":true,"path":"about/index.html","permalink":"http://nty99.gitee.io/about/","excerpt":"","text":""},{"title":"友情链接","date":"2022-08-23T03:59:28.711Z","updated":"2022-08-23T03:59:28.706Z","comments":true,"path":"links/index.html","permalink":"http://nty99.gitee.io/links/","excerpt":"","text":""},{"title":"friends","date":"2022-08-26T03:47:35.000Z","updated":"2022-08-26T03:48:08.749Z","comments":true,"path":"friends/index.html","permalink":"http://nty99.gitee.io/friends/","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2022-08-26T06:34:50.809Z","comments":true,"path":"contact/index.html","permalink":"http://nty99.gitee.io/contact/","excerpt":"","text":""},{"title":"仓库","date":"2022-08-23T03:11:53.583Z","updated":"2022-08-23T03:11:53.572Z","comments":false,"path":"repository/index.html","permalink":"http://nty99.gitee.io/repository/","excerpt":"","text":""},{"title":"标签","date":"2022-08-22T01:49:45.000Z","updated":"2022-08-22T03:51:03.784Z","comments":true,"path":"tags/index.html","permalink":"http://nty99.gitee.io/tags/","excerpt":"","text":""}],"posts":[{"title":"Mac","slug":"Mac","date":"2022-08-23T07:05:13.000Z","updated":"2022-09-01T03:32:42.681Z","comments":true,"path":"2022/08/23/mac/","link":"","permalink":"http://nty99.gitee.io/2022/08/23/mac/","excerpt":"","text":"十一、Mac 12345678910111213141516171819202122232425262728293031一、主机名：就是HostName。查看：scutil --get HostName修改：sudo scutil --set HostName 新的主机名二、计算机名：就是ComputerName。它在隔空投送中显示，查看：scutil --get ComputerName修改：方法一：在“设置”——“共享”下，修改“电脑名称”。方法二：sudo scutil --set ComputerName 新的计算机名三、本地主机名（即：本地局域网主机名）它在局域网中显示，可在finder下的网络查看。修改：在“设置”——“共享”下，再点下图中的“编辑”按钮，进去就可以修改了。四、修改xcode作者名修改：设置——用户与群组——点击左下角小锁，解锁——在当前用户上右键，点“高级选项”，修改“全名”，就可以了五、修改终端前缀macOS 的终端前缀默认是 PS1=\"%n@%m %1~ %# \"。%n: 表示用户名称，这里是账户名称，可以在（设置——用户与群组——点击左下角小锁，解锁——在当前用户上右键，点“高级选项”，查看账户名称，这里是改不了的）%m: 主机名%1~: 所在的当前目录%#: 最后的分隔符号修改：1. 终端输入 open /etc2. 在打开的文件夹找到bashrc 或者zshrc（取决于你用的哪种终端命令），复制一份到桌面，打开桌面上的这份修改PS1，比如修改成PS1=\"%n %1~ %# \"，修改前最好把原命令注释一份，然后command+s保存3.删除 /etc/bashrc 或者/etc/zshrc，桌面上的那份复制或移动过来。4.终端执行source /etc/bashrc 或者source /etc/zshrc，让文件生效。","categories":[],"tags":[]},{"title":"设计模式","slug":"设计模式","date":"2022-08-23T06:53:20.000Z","updated":"2022-09-01T03:33:14.650Z","comments":true,"path":"2022/08/23/design/","link":"","permalink":"http://nty99.gitee.io/2022/08/23/design/","excerpt":"","text":"1、创建型模式123456789101112131415161718192021222324252627282930313233343536373839404142主要特点是将对象的创建和使用分离 (1)单例模式 饿汉式：类加载就会导致该实例对象被创建 懒汉式：首次使用该对象才会创建 推荐方式： 枚举方式 双重检查锁+volatile关键字 静态类部类方式 破坏单例： 序列化：解决方案:在序列化的类中新增readResolve()方法,ObjectInputStream会判断有无这个方法，有就执行 反射：解决方案：通过构造方法创建对象时候，添加判断---(多线程环境加上同步代码块)(2)工厂方法模式(3)抽象工厂模式 抽象工厂模式是工厂模式的升级，工厂模式只生产同一等级的产品，抽象工厂可生产多个等级的产品 使用场景： 1、当创建的对象是一系列相互关联或相互依赖的产品族，如电器工厂的洗衣机、电视剧、冰箱 2、系统中有多个产品族，但每次只使用某一族产品。如穿不同品牌的衣服、鞋子 3、系统中提供了产品的类库，且所有产品接口相同，客户端不依赖产品实例的创建细节和内部结构 如输入法皮肤更换等等。(4)原型模式：用一个已经创建的实例作原型，通过复制该原型对象来创建一个和原型对象相同的新对象 角色： 1、抽象原型类：规定了具体原型对象必须实现的clone()方法 2、具体原型类：实现抽象原型类的clone方法，它是可被复制的对象 3、访问类：使用具体原型类的clone方法复制新对象 使用场景: 1、对象创建复杂，可使用原型模式快速克隆 2、性能和安全要求比较高 浅克隆：Object的clone方法是浅克隆，克隆的新对象属性和原对象相同，对于非基本类型属性，克隆对象属性内存地址指向原有对象属性 深克隆：克隆出新对象，原对象属性中的其它对象也会被克隆，不再指向原对象属性内存地址(5)建造者模式 将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示 使用场景： 1、创建的对象较复杂，由多个部件构成，各部门面临复杂的变化，但是部件间的构造顺序的稳定的 2、产品构建和装配方式是分离的，即产品的构建过程和最终的表示是相互独立的创建型模式对比： 1、工厂方法模式VS建造者模式 工厂方法模式注重于整体对象的创建 建造者模式注重于部件的构建过程，意在通过一步步的精确构建出一个复杂的对象 2、抽象工厂模式VS建造者模式 抽象工厂模式实现对产品家族的创建，一个产品家族是这样一系列产品；具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产 建造者模式主要目的是通过组装零配件产生一个新产品 2、结构型模式12345678 用于描述如何将对象按照某种布局组成更大的结构，分为类结构模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。后者耦合度低，满足\"合成复用原则\",所以对象型结构模式比类结构型模式更灵活。(1)代理模式(2)适配器模式(2)装饰者模式(2)桥接模式(2)外观模式(2)组合模式(2)享元模式 1、代理模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667（1）动态代理 private static TrainStation station = new TrainStation();SellTicket proxyInstance = (SellTicket) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"增强\"); return method.invoke(station, args); } });proxyInstance.sellTicket();原理: 1、调用proxyInstance.sellTicket()，根据多肽会执行动态代理动态生成的$Proxy0的sellTicket()方法 2、根据构造方法生成$Proxy0对象，会将自定义的new InvocationHandler(){}传递给父类Proxy的构造方法，复制给父类的成员变量InvocationHandler 3、执行super.h.invoke(this, m3, (Object[])null)方法会调用自己的invoke方法 4、invoke方法中会通过反射调用真实对象的Proxy0的sellTicket()方法 public final class $Proxy0 extends Proxy implements SellTicket { private static Method m3; public $Proxy0(InvocationHandler var1) throws { super(var1); } public final void sellTicket() throws { super.h.invoke(this, m3, (Object[])null); } static { m3 = Class.forName(\"com.study.nty.design.proxy.SellTicket\").getMethod(\"sellTicket\"); }}（2）CGLIB代理 private static TrainStation station = new TrainStation(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(TrainStation.class); enhancer.setCallback( new MethodInterceptor() { @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(\"动态增强\"); return method.invoke(station,args); } }); TrainStation proxy = (TrainStation) enhancer.create(); proxy.sellTicket();原理: 1、执行proxy.sellTicket()方法会执行MethodInterceptor对象的intercept方法 Cglib底层采用ASM字节码生成框架，使用字节码技术生成代理类，Cglib不能对final修饰的类或方法进行代理，因为Cglib动态生产的类是目标对象的子类。 动态代理和静态代理区别 动态代理会将接口或类中的方法集中在处理器的方法中执行，这样在目标对象的方法比较多的时候能灵活处理，不用像静态代理那样在每个方法都重写、处理。代理模式优缺点 优点 · 代理模式中客户端和目标对象之间提供中介和保护作用 · 可以对象目标对象的功能进行增强 · 使客户端和目标对象分离，降低系统耦合度 缺点 · 增加系统复杂度 2、适配器模式123456定义：将一个类的接口转换成客户希望的另外的接口，使得原本不能兼容的东西变成兼容。分为类适配器和对象适配器，前者耦合度比较高，应用少结构： · 目标接口（Target）：当前系统业务所期待的接口 · 适配者（Adaptee）：被访问和适配现存组件的接口 · 适配器（Adapter）：转换器，通过继承或引用适配者对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者 3、装饰者模式4、桥接模式​ 1、角色 ​ (1)抽象化角色：定义抽象类，并包含对实现化角色的引用 ​ (2)扩展抽象化角色：继承抽象化角色，重写父类方法，通过组合关系调用实现化角色的方法 ​ (3)实现化角色：定义接口，供扩展抽象化角色调用 ​ (4)具体实现化角色：给出实现化角色的接口的具体实现 5、门面模式6、组合模式​ 1、角色 ​ (1)抽象根节点：定义系统各层次对象共有的方法和属性，可以预先定义一些默认方法和属性 ​ (2)树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构 ​ (3)叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位 ​ 2、分类 ​ (1)透明模式 ​ (2)安全模式 3、行为型模式 （1）用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。 7、享元模式​ 1、结构 ​ (1)内部状态：不会随环境改变而改变的可共享的部分 ​ (2)外部状态：指随环境的改变而改变的不可共享的部分 ​ 2、角色 ​ (1)抽象享元角色：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据(内部状态)，同时也可以通过这些方法来设置外部数据(外部状态)。 ​ (2)具体享元角色：实现了抽象享元类，称为享元对象。在具体享元类中为内部状态提供了存储空间。通常我们可以结合单利模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 ​ (3)非享元角色：并不是所有抽象享元类的子类需要被共享，不能被共享的子类可设计成非共享享元类。当需要非共享具体享元对象时候可以直接实例化创建。 ​ (4)享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时候，享元工厂检查是否存在符合要求的享元对象，如果存在则提供，不存在则创建。 3、行为型模式1、模板方法模式​ 1、角色 ​ (1)抽象类：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。 ​ · 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法 ​ · 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法也可以分为三种： ​ · · 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现 ​ · · 具体方法：一个具体方法由一个抽象类或具体类声明实现，其子类可以覆盖也可以直接继承 ​ · · 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法。一般钩子方法是用于判断的逻辑方法， 这种方法名一般为isXxx，返回值是boolean类型。 ​ (2)具体子类：实现抽象类中定义的抽象方法和钩子方法，它们是一个顶级逻辑的的组成步骤 2、策略模式3、命令模式4、责任链模式5、状态模式6、观察者模式7、中介者模式8、迭代器模式9、访问者模式10、备忘录模式11、解释器模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://nty99.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"Linux","slug":"Linux","date":"2022-08-23T06:53:03.000Z","updated":"2022-09-01T03:33:29.784Z","comments":true,"path":"2022/08/23/linux/","link":"","permalink":"http://nty99.gitee.io/2022/08/23/linux/","excerpt":"","text":"七、Linux常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960611、进程端口查看查看进程： ps -ef | grep (名称/进程id) 和(ps aux类似，其中ps -aux是显示x用户的进程) 如:ps -ef | grep java ps -ef | grep 进程pid 查看端口： (1) netstat -an|grep 8080 (2) lsof -i:80802、压缩解压命令： 压缩：tar -czf all.tar.gz *.jpg 解压：tar -xzf all.tar.gz3、防火墙端口 firewall-cmd --query-port=8848/tcp firewall-cmd --permanent --remove-port=8848/tcp firewall-cmd --zone=public --add-port=8080-8090/tcp --permanent systemctl restart firewalld.service firewall-cmd --reload4、不挂断的运行命令 nohup ./test.sh &amp;5、查看当前后台运行的命令 (1)jobs用于查看当前终端后台运行的任务，换了终端就看不到了。 jobs jobs -l 选项可显示当前终端所有任务的PID (2)ps命令用于查看瞬间进程的动态，可以看到别的终端运行的后台进程。 ps -aux | grep \"test.sh\" #a:显示所有程序 u:以用户为主的 x:显示所有程序，不以终端机来区分6、kill命令 (1)kill pid 正常停止该进程 = kill -15 pid = kill -s TERM (2)kill -9 pid 强制杀死该进程 = kill -s SIGKILL pid (3)kill -1 pid 重启该进程 = kill -s SIGHUP pid6、关闭当前后台运行的命令 (1)通过jobs命令查看jobnum，然后执行 kill %jobnum (2)通过ps命令查看进程号PID，然后执行 kill PID 如果是前台进程的话，直接执行 Ctrl+c 就可以终止了7、前后台进程的切换与控制 (1)fg 功能：将后台中的命令调至前台继续运行 如果后台中有多个命令，可以先用jobs查看jobnum，然后用fg %jobnum 将选中的命令调出。 (2)Ctrl+z 功能：将一个正在前台执行的命令放到后台，并且处于暂停状态 (3)bg 功能：将一个在后台暂停的命令，变成在后台继续执行 (4)watch watch -n 10 sh test.sh &amp; #每10s在后台执行一次test.sh脚本 (5)nohup 功能：如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的&amp;做不到） nohub ./test.sh &gt; r.log 2&gt;&amp;1 &amp;8、特殊符号 (1)运行jar包，并且置于后台执行，执行的日志重定向到当前默认的log.txt文件中 java -jar test.jar &gt; log.txt &amp; (2)&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令。 ls -l &amp;&amp; cd .. (3)|| 表示上一条命令执行失败后，才执行下一条命令。 als -l || cd .. (4)&gt; 表示stdout标准输出信息重定向输出，覆盖写。 echo 'World' &gt; test.txt (5)&gt;&gt; 表示内容追加写。 echo 'World' &gt;&gt; test.txt (6)&amp;&gt; 表示stdout标准输出和stderr错误输出信息，重定向输出，覆盖写。 lll &amp;&gt; test.txt (7)2&gt;&amp;1 表示把标准错误的输出重定向到标准输出1，&amp;指示不要把1当做普通文件，而是fd=1即标准输出处理。 (8)2&gt;1 表示把标准错误的输出重定向到1，但这个1不是标准输出，而是一个名为1的文件。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://nty99.gitee.io/categories/Linux/"}],"tags":[]},{"title":"中间件","slug":"中间件","date":"2022-08-23T06:52:44.000Z","updated":"2022-09-01T03:33:24.876Z","comments":true,"path":"2022/08/23/middleware/","link":"","permalink":"http://nty99.gitee.io/2022/08/23/middleware/","excerpt":"","text":"五、中间件5.1、RabbitMQ​ 工作模式： 1 “Hello World!”、2 Work queues、3 Publish/Subscribe、4 Routing、5 Topics​ (1)1和2使用默认交换机​ (2)Publish/Subscribe使用FANOUT(给所有绑定的队列发送消息，此时不用指定routingKey)​ (3)Routing使用DIRECT(给指定的routingKey发送消息)​ (4)Topics使用TOPIC(给匹配的路由发送消息)","categories":[{"name":"中间件","slug":"中间件","permalink":"http://nty99.gitee.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[]},{"title":"部署","slug":"部署","date":"2022-08-23T06:52:35.000Z","updated":"2022-09-01T03:32:55.126Z","comments":true,"path":"2022/08/23/deploy/","link":"","permalink":"http://nty99.gitee.io/2022/08/23/deploy/","excerpt":"","text":"1、docker常用命令12345678910111213docker pull 服务:tag 服务:版本（拉取服务，不加tag则默认最新版）docker images 查看镜像docker save -o nginx.tar nginx:lastest 将nginx:latest镜像打包docker load -i nginx.tar 加载镜像docker rmi 删除镜像docker rm 删除容器 -f 删除运行的容器docker ps 查看运行容器状态 -a 则查看所有容器状态docker run --name 取名字 -p 80:80 -d 镜像 运行镜像，-p端口映射，-d后台运行docker logs mn 查看mn容器的日志 -f 动态查看docker exec -it mn bash 以bash命令进入mn容器docker stop mn 停止mn容器docker (un)pause （恢复）暂停镜像docker restart mn 重启mn容器 2、docker镜像结构1、镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。 2、镜像是分成结构、每一层称为一个Layer ​ （1）BaseImage层:包含基本的系统函数库、环境变量、文件系统 ​ （2）Entrypoint：入口，是镜像中应用启动的命令 ​ （3）其它：在BaseImage基础上添加依赖、安装程序、完成整改个应用的安装和配置","categories":[{"name":"部署","slug":"部署","permalink":"http://nty99.gitee.io/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[]},{"title":"数据库","slug":"数据库","date":"2022-08-23T06:52:23.000Z","updated":"2022-09-01T03:33:19.757Z","comments":true,"path":"2022/08/23/database/","link":"","permalink":"http://nty99.gitee.io/2022/08/23/database/","excerpt":"","text":"1、Mysql1、执行顺序​ 1、执行where xx对全表数据做筛选，返回第1个结果集 ​ 2、针对第1个结果集使用group by分组，返回第2个结果集 ​ 3、针对第2个结果集中的每1组数据执行select xx，有几组就执行几次，返回第3个结果集 ​ 4、针对第3个结集执行having xx进行筛选，返回第4个结果集 ​ 5、针对第4个结果集排序 ​ 6、完整顺序:from、join、where、group by、with、having、order 2、索引​ 1、数据结构 ​ (1)Innob主键索引是聚集索引方式，数据和索引都在同一个文件里面，主键索引叶子节点存储的是数据，二级索引即非聚簇索引叶子节点存储的是主键key，主索引叶子节点存储的是数据。 ​ (2)MyISAM 用的是非聚集索引方式，即数据和索引落在不同的两个文件上。MyISAM 在建表时以主键作为 KEY 来建立主索引B+树，树的叶子节点存的是对应数据的物理地址。我们拿到这个物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录了。 ​ 2、选择条件 ​ (1)较频繁的作为查询条件的字段应该创建索引； ​ (2)唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件； ​ (3)更新非常频繁的字段不适合创建索引。 ​ 3、分类 ​ 1、聚簇索引:数据存储的一种方式，索引的顺序和数据记录的顺序一致 ​ 2、非聚簇索引:索引顺序和存储顺序无关 3、count​ 1、count(*)包括了所有的列，相当于行数，在统计结果的时候， 不会忽略列值为NULL ​ 2、count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候， 不会忽略列值为NULL ​ 3、count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空(这里的空不是只空字符串或者0，而是表示null)的计数， 即某 个字段值为NULL时，不统计。 ​ 4、列名为主键，count(列名)会比count(1)快 ​ 5、列名不为主键，count(1)会比count(列名)快 ​ 6、如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） ​ 7、如果有主键，则 select count（主键）的执行效率是最优的 ​ 8、如果表只有一个字段，则 select count（*）最优 4、存储引擎​ 1、类型 ​ InnoDB、MyISAM ​ 2、区别 ​ (1)InnoDB 支持事务，MyISAM不支持事务 ​ (2)InnoDB支持外键，MyISAM不支持 ​ (3)InnoDB支持行锁和表锁，ISAM不支持行锁 ​ (4)InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数， 执行上述语句时只需要读出该变量即可，速度很快。 5、执行计划6、最左前缀原则​ 如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，遇到范围查询时 候停止匹配。 7、优化器8、锁的分类和作用​ 1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 ​ 2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 ​ 3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 Tips​ 1、默认查询是不分大小写，若需要区分，可在建表时候指定，或者在查询时候在字段前面加上binary 2、OracleTips​ 1、Oracle执行sql的的隐式转换 ​ 2、Oracle DROP误删表后恢复 ​ (1)SELECT * FROM USER_RECYCLEBIN ​ (2)FLASHBACK TABLE TABLE_NAME TO BEFORE DROP; ​ 3、删除Table不进入Recycle的方法：DROP TABLE TABLE_NAME PURGE 即永 3、Redis1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950hash双链集合，set、zset、list单链集合exists key 查看key是否存在incr/decr key (key的值增加/减少1)incrby/decrby key n (key的值增加/减少n) 单个命令实现的所有Redis操作都是原子的，包括对更复杂数据结构的操作。因此，当您使用修改某些值的 Redis 命令时，您不必考虑并发访问。set key value ex time 设置键的过期时间ttl key 查看键的过期时间 -1 永久 -2 失效 20 20秒后失效persist key 移除key的过期时间列表：listllen key 查看列表长度lpush / rpush key value（向列表头 / 尾插入信息）lrange key 0 -1 （遍历从头到尾的值）lange key 0 -2 （遍历从头到倒数第二个值）lpop / rpop 删除头 / 尾的key，并把删除的值返回lpush / rpush key value1,value2 向列表插入多个值，返回列表长度集合：setsadd key value... 向集合中添加一个或多个元素smembers key 遍历集合元素srem key value 删除指定元素，存在返回1，不存在返回0sismember key value 查看值是否存在，存在返回1，不存在返回0sunion key1 key2 组合多个集合并返回所有元素spop key n 随机删除n个元素并返回，默认返回一个srandmember key n 随机返回集合中的n个元素，不写默认返回一个sdiff key1 key2返回两个集合的差别集合：zsetzadd key_namae score value... 向有序集合添加一个或多个值(可修改指定值的分数)zrange key_name start end 获取指定范围内按score排序的集合zrange key start end withscores 打印所有的value，并带有分数zscore key value 获取指定value的score哈希：hashhset key filed filed 添加一个或多个键值对hget key filed 获取某个键值对hgetall key 获取所有键值对hincrby key filed n 给字段key增加n个整数值hdel key filed 删除字段的值 hlen、hkeys、hvals key 打印键值对长度、所有的key、所有的值redis两种持久化方案：RDB: save 900 1 save 300 10 save 60 10000 （60秒后有10000条数据发生变化则进行持久化） AOF: 开启appendonly 为yes # appendfsync always （每次操作进行一次持久化） appendfsync everysec （每秒进行一次持久化） # appendfsync no 4、ES1、配置ES开发环境123456789101112131415161718docker run -d \\ --name es \\ -e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" \\ -e \"discovery.type=single-node\" \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\elasticsearch:7.12.1docker run -d \\ --name kibana \\ -e ELASTICSEARCH_HOSTS=http://es:9200 \\ --network es-net \\ -p 5601:5601 \\kibana:7.12.1 2、DSL语句​ 1、索引库操作 123456789101112131415161718192021222324252627282930313233343536373839404142#查看索引库GET /hotel#删除索引库DELETE /hotel#修改索引库 只能增添字段PUT /hotel/_mapping{ \"properties\":{ \"age\":{ \"type\":\"integer\" } }}# 建立索引库hotel type数据类型 analyzer分词器PUT /hotel{ \"mappings\": { \"properties\": { \"id\":{ \"type\": \"keyword\" }, \"name\":{ \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"copy_to\": \"all\" }, \"address\":{ \"type\": \"text\" }, \"price\":{ \"type\": \"integer\" }, \"all\":{ \"type\": \"text\", \"analyzer\": \"ik_max_word\" } } }} ​ 2、文档操作 1234567891011121314151617181920212223242526272829303132#新增文档id为1的数据POST /hotel/_doc/1{ \"id\":\"1\", \"name\":\"test\", \"address\":\"test\", \"price\":11}#查询id为1的数据GET /hotel/_doc/1#删除id为1的数据DELETE /hotel/_doc/1#修改数据 全量修改 如果数据不存在则创建PUT /hotel/_doc/1{ \"id\":\"1\", \"name\":\"test\", \"address\":\"test\", \"price\":11}#修改数据 增量修改字段POST /hotel/_update/1{ \"doc\": { \"address\":\"杭州\", \"price\":10000000 }} ​ 3、查询操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#全文搜索GET /hotel/_search{ \"query\":{ \"match_all\": {} }}#单字段查询 all 多个字段整合GET /hotel/_search{ \"query\":{ \"match\": { \"all\": \"如家商圈\" } }}#多字段查询GET /hotel/_search{ \"query\":{ \"multi_match\": { \"query\": \"如家商圈\", \"fields\": [\"brand\",\"name\",\"business\"] } }}#精确查询GET /hotel/_search{ \"query\": { \"term\": { \"city\": { \"value\": \"上海\" } } }}#精确查询 范围查询 带e表示包含等于GET /hotel/_search{ \"query\": { \"range\": { \"price\": { \"gte\": 1000, \"lte\": 2000 } } }}#位置查询 geo_distance和geo_bounding_boxGET /hotel/_search{ \"query\": { \"geo_distance\": { \"distance\":\"10km\", \"location\":\"31.20, 121.30\" } }}#function_score查询 会修改最后得分 query_score和function_score来决定分数GET /hotel/_search{ \"query\": { \"function_score\": { \"query\": { \"match\": { \"name\": \"酒店\" } }, \"functions\": [ { \"filter\": { \"term\": { \"brand\": \"7天酒店\" } }, \"weight\": 10 } ], \"boost_mode\": \"sum\" } }}#bool查询 must_not和filter不会修改算分GET /hotel/_search{ \"query\": { \"bool\": { \"must\": [ { \"match\": { \"name\": \"如家\" } } ], \"must_not\": [ { \"range\": { \"price\": { \"gt\": 500 } } } ], \"filter\": [ { \"geo_distance\": { \"distance\": \"10km\", \"location\": { \"lat\": 39.945106, \"lon\": 116.353827 } } } ] } }}#sort排序 会放弃打分GET /hotel/_search{ \"query\": { \"match_all\": {} }, \"sort\": [ { \"score\": \"asc\" }, { \"price\": \"desc\" } ]}#sort排序 按地理位置排序GET /hotel/_search{ \"query\": { \"match_all\": {} }, \"sort\": [ { \"_geo_distance\": { \"location\": \"10.10,10.10\", \"order\": \"asc\", \"unit\": \"km\" } } ]}#分页查询 结果集(from+size)不能超过10000 还可以写成search after(需排序,记录上次查询的最后一个文档,查询下一页数据)GET /hotel/_search{ \"query\": { \"match_all\": {} }, \"sort\": [ { \"price\": \"desc\" } ], \"from\": 0, \"size\": 10}#高亮GET /hotel/_search{ \"query\": { \"match\": { \"all\": \"如家\" } }, \"highlight\": { \"fields\": { \"name\": { \"require_field_match\": \"false\" } } }} ​ 4、聚合查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#聚合查询bucket 200元以下的酒店按品牌分组后的数量升序展示10条数据GET /hotel/_search{ \"query\": { \"range\": { \"price\": { \"lte\": 200 } } }, \"size\": 0, \"aggs\": { \"brandAggs\": { \"terms\": { \"field\": \"brand\", \"size\": 10, \"order\": { \"_count\": \"asc\" } } } }}#聚合查询 bucket+metrics 对分组后的品牌按平均分进行降序排序GET /hotel/_search{ \"size\": 0, \"aggs\": { \"brandAggs\": { \"terms\": { \"field\": \"brand\", \"size\": 5, \"order\": { \"scoreAggs.avg\": \"desc\" } }, \"aggs\": { \"scoreAggs\": { \"stats\": { \"field\": \"score\" } } } } }} ​ 5、自定义分词器 12345678910111213141516171819202122232425#创建分词器和搜索分词器不能混用 因为有可能词汇汉字不一样但是拼音一样导致搜索结果达不到预期效果PUT /test{ \"settings\": { \"analysis\": { \"analyzer\": { \"my_analyzer\": { \"tokenizer\": \"ik_max_word\", \"filter\": \"py\" } }, \"filter\": { \"py\": { \"type\": \"pinyin\", \"keep_full_pinyin\": false, \"keep_joined_full_pinyin\": true, \"keep_original\": true, \"limit_first_letter_length\": 16, \"remove_duplicated_term\": true, \"none_chinese_pinyin_tokenize\": false } } } }}","categories":[{"name":"数据库","slug":"数据库","permalink":"http://nty99.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"框架","slug":"框架","date":"2022-08-23T06:52:10.000Z","updated":"2022-09-01T03:33:08.360Z","comments":true,"path":"2022/08/23/frame/","link":"","permalink":"http://nty99.gitee.io/2022/08/23/frame/","excerpt":"","text":"一、SpringBoot1、bean的生命周期​ 1、Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化 ​ 2、Bean实例化后对将Bean的引入和值注入到Bean的属性中 ​ 3、如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法 ​ 4、如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入 ​ 5、如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下 文引用传入进来。 ​ 6、如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。 ​ 7、如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了 初始化方法，该方法也会被调用 ​ 8、如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。 ​ 9、此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。 ​ 10、如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销 毁方法，该方法也会被调用。 2、SpringMVC的执行流程​ 1、用户发送请求至前端控制器DispatcherServlet ​ 2、DispatcherServlet收到请求调用处理器映射器HandlerMapping。 ​ 3、处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返 回给DispatcherServlet。 ​ 4、DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封 装，数据格式转换，数据验证等操作 ​ 5、执行处理器Handler(Controller，也叫页面控制器)。 ​ 6、Handler执行完成返回ModelAndView ​ 7、HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet ​ 8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器 ​ 9、ViewReslover解析后返回具体View ​ 10、DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。 ​ 11、DispatcherServlet响应用户。 3、SpringBoot配置优先级​ 1、配置优先级 ​ （1）命令行参数 ​ （2）来自 java:comp/env 的 JNDI 属性 ​ （3）Java 系统属性（System.getProperties()） ​ （4）操作系统环境变量 ​ （5）RandomValuePropertySource 配置的 random.* 属性值 ​ （6）配置文件（YAML文件、Properties 文件） ​ （7）@Configuration 注解类上的 @PropertySource 指定的配置文件 ​ （8）通过SpringApplication.setDefaultProperties 指定的默认属性 ​ 2、配置文件优先级 4、Gateway​ GatewayFilter Factories中有30种过滤器，spring gateway网关中过滤器执行顺序按照order的值执行，值越小，优先级越高 globalFilter的order值由我们自己指定，defaultFilter和路由filter由spring声明式指定，如果值一样，则执行defaultFilter、路由 filter、globalFilter。defaultFilter和路由filter类型是GatewayFilter，globalFilter经过GatewayFilterAdapter转换成GatewayFilter 5、AOP​ 1、不存在环绕通知执行顺序： 12341 before执行2 方法执行3 AfterThrow执行4 After执行 ​ 2、存在环绕通知@Around执行顺序： 1234567891011121314151617181920212223242526272829@Before(\"point()\")public void before(JoinPoint joinPoint){ System.out.println(\"2 before执行\");}@After(\"point()\")public void after(JoinPoint joinPoint){ System.out.println(\"5 After执行\");}@AfterReturning(\"point()\")public void afterReturning(JoinPoint joinPoint){ System.out.println(\"4 AfterReturning执行\");}@AfterThrowing(pointcut = \"point()\")public void afterThrowing(JoinPoint joinPoint){ System.out.println(\"4 AfterThrow执行\");}@Around(\"point()\")public Object test(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"1 around前执行\"); //3、目标方法执行 Controller层方法 //6、切点执行 Object proceed = joinPoint.proceed(); System.out.println(\"7 around后执行\"); return proceed;} 6、加载顺序​ 1、同一个类中加载顺序 ​ Constructor &gt;&gt; @Autowired &gt;&gt;@ PostConstruct&gt;&gt;@Bean，跟Bean生命周期有关 ​ 2、@Order注解并不能改变Bean加载优先级，@Order注解用于设置装载到list中Bean的顺序，用于比较多的是 控制AOP的类的加载顺序，也就是被@Aspect标注的类 控制ApplicationListener实现类的加载顺序 控制CommandLineRunner实现类的加载顺序 ​ 3、@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder这三个注解是给Springboot自动配置类排序使用的，注 意是自动配置类(META_INF下的spring.factories配置文件)，并非是普通的配置类。 ​ 4、@DependsOn注解可以用来控制bean的创建顺序，该注解用于声明当前bean依赖于另外一个bean。所依赖的bean会被容器确保 在当前bean实例化之前被实例化。 ​ 5、在@Bean标注的方法上，如果你传入了参数，springboot会自动会为这个参数在spring上下文里寻找这个类型的引用。并先初始化 这个类的实例。利用此特性，我们也可以控制bean的加载顺序。 7、约定大于配置​ 1、开发人员仅需规定应用中不符合约定的部分 ​ 2、在没有规定配置的地方，采用默认配置，以力求最简配置为核心思想总的来说，上面两条都遵循了推荐默认配置的思想。当存在特 殊需求的时候，自定义配置即可。这样可以大大的减少配置工作，这就是所谓的“约定”。 8、校验​ 1、官方提供：@NotBlank、@Size等。tips(除了@NotNull、@NotBlank外，其它的不会对null进行校验) ​ 2、自定义: 需在自定义注解上使用元注解@Constraint(validatedBy = xxx.class)，xxx.class实现ConstraintValidator接口进行处理 9、条件注解​ 1、@ConditionalOnProperty两个属性matchIfMissing、havingValue ​ (1)没有havingValue属性时候，matchIfMissing为true时，配置文件缺少字段也会注入成功，为false时有配置信息则可以注入，没有则不会注入 ​ (2)有havingValue时候，havingValue值必须和配置值相同才会注入成功，不管matchIfMissing的值 10、依赖注入​ 1、通过构造方法注入 ​ (1)采用构造方法上带有@Autowired注解注入 ​ (2)无@Autowired时候，若有无参构造则采用无参构造，无则采用其它构造方法 ​ 2、setter注入 ​ (1)在需要注入的setter方法上加@Autored、@Resource注解 ​ (2)只要setter方法上有@Autored、@Resource注解则一定会执行此注入方式，不管有无构造注入、字段注入 二、Mybatis1、问题​ (1)mapper层使用Integer、String等做参数时候，出现There is no getter for property named ‘xxx’ in ‘class java.lang.String’ 123456789101112131415161、在mapper层使用@Param映射2、使用_parameter、value做参数 &lt;select id=\"test\" resultType=\"java.lang.Integer\"&gt; SELECT ... &lt;!--字符串比较加toString()-&gt; &lt;choose&gt; &lt;when test=\"param == '0'.toString()\"&gt; ... &lt;/when&gt; ------- &lt;when test=\"_parameter == '0'.toString()\"&gt; ... &lt;/when&gt; &lt;/choose&gt; &lt;/select&gt; 2、#和$区别​ (1)使用#{param}，是经过预编译的，会将传递过来的参数换转换成“param” ​ (2)使用${param}，是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入问题。 3、一、二级缓存​ (1)spring结合mybatis后，在未开启事物的情况之下，每次查询，spring都会关闭旧的sqlSession而创建新的sqlSession,因此此时的 一级缓存是没有启作用的。在开启事物的情况之下，spring使用threadLocal获取当前资源绑定同一个sqlSession，因此此时一级缓存是 有效的。 ​ (2)查出的数据都会被默认先放在一级缓存中。只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中 ​ (3)一级缓存：sqlSession级别的缓存。（相当于一个方法内的缓存）每一次会话都对应自己的一级缓存，作用范围比较小，一旦会话 关闭就查询不到了；一级缓存默认是一直开启的，是SqlSession级别的一个Map；与数据库同一次会话期间查询到的数据会放在本地缓存 中。 ​ (4)基于namespace名称空间级别的缓存：一个namespace对应一个二级缓存，一个会话，查询一条数据，这个数据就会被放在当前会 话的一级缓存中。 ​ (5)如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容。 4、二级缓存开启​ (1)开启全局二级缓存配置： ​ (2)去mapper.xml中配置使用二级缓存： ​ (3)我们的POJO需要实现序列化接口 5、一级缓存失效原因​ (1)不同的会话对象 ​ (2)会话对象相同，查询不在缓存中的内容 ​ (3)两次查询期间进行了增删改的操作 ​ (4)会话完成后手动清空缓存 6、缓存执行顺序​ (1)先判断二级缓存是否开启，如果没开启，再判断一级缓存是否开启，如果没开启，直接查数据库 ​ (2)如果一级缓存关闭，即使二级缓存开启也没有数据，因为二级缓存的数据从一级缓存获取 ​ (3)一般不会关闭一级缓存 ​ (4)二级缓存默认不开启 ​ (5)如果二级缓存关闭，直接判断一级缓存是否有数据，如果没有就查数据库 ​ (6)如果二级缓存开启，先判断二级缓存有没有数据，如果有就直接返回；如果没有，就查询一级缓存，如果有就返回，没有就查询数 据库。 三、Nacos​ 1、负载均衡策略：配置同集群访问后，优先随机访问同集群，当本集群的实例宕机了再访问其他集群的实例，此时会有警告产生，跨 集群访问 ​ 2、服务默认为临时实例，配置服务为非临时实例时，Nacos主动询问实例是否健康，若服务宕机后会立即pull给消费者，且Nacos不会 剔除服务。 ​ 3、配置namespace环境隔离，则不同环境的服务不能通信 四、Nginx​ 1、在nginx中配置proxy_pass时，如果在proxy_pass后面的url加/，相当于是绝对根路径，则nginx不会把location中匹配的路径部分代理走。如果没有/，则会把匹配的路径部分给代理走。比如访问：127.0.0.1/a/index.html 123456789101112131415161718location /a { proxy_pass http://127.0.0.1/}相当于http://127.0.0.1/index.htmllocation /a { proxy_pass http://127.0.0.1}相当于http://127.0.0.1/a/index.htmllocation /a { proxy_pass http://127.0.0.1/linux/}相当于http://127.0.0.1/linux/index.htmllocation /a { proxy_pass http://127.0.0.1/linux}相当于http://127.0.0.1/linuxindex.html 五、Ribbon1、原理​ (1)发送请求被RibbonLoadBalancerClient拦截 ​ (2)获取请求中的服务名称 ​ (3)交给DynamicServerListLoadBalancer去注册中心拉去服务地址 ​ (4)返回服务列表给DynamicServerListLoadBalancer，匹配IRule定义的策略选择服务 ​ (5)用服务地址替换原来的地址发送请求 2、负载均衡策略​ (1)Bean方式，全局 1234@Beanpublic IRule randomRule(){ return new RandomRule();} ​ (2)配置方式，局部、灵活 123服务名称: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 3、Ribbon加载方式​ 默认采用懒加载所以第一次调用时间会长，可以配置采用饥饿加载，服务启动就把服务地址缓存在DynamicServerListLoadBalancer 12345ribbon: eager-load: enabled: true # 开启饥饿加载 clients: # 指定饥饿加载的服务名称 - userservice 六、Logback1、日志两大规范​ (1)Commons Logging (JCL) ​ (2)Simple Logging Facade for JAVA (slf4j) ​ 由于log4j性能问题，采用logback替代log4j 2、日志级别​ (1)级别程度是：TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR (2)默认级别debug，只能输出级别大于或者等于此级别的信息，例如设置为INFO，则只能输出INFO、WARN、ERROR的日志信息","categories":[{"name":"Java","slug":"Java","permalink":"http://nty99.gitee.io/categories/Java/"}],"tags":[]},{"title":"基础","slug":"基础","date":"2022-08-23T06:51:21.000Z","updated":"2022-09-01T03:33:01.388Z","comments":true,"path":"2022/08/23/base/","link":"","permalink":"http://nty99.gitee.io/2022/08/23/base/","excerpt":"","text":"一、HashMap1、常见Map比较​ 1、hashmap 线程不安全，只允许有一个key为null，允许多个value为null ​ 2、hashtable线程安全，用的是内置锁synchronized，不允许key或value为null ​ 3、linkedhashmap 能保留put 键值对的顺序 ​ 4、treemap实现sortmap接口能默认对put的键值对进行key排序 2、ConcurrentHashMap​ 1、concurentHashMap与hashmap本质上并没有什么区别，只是concurrenthashMap是线程安全的 ​ 2、jdk1.7 采用了Segment分段锁，锁住几个槽位 ​ 3、jdk1.8则采用 Node +CAS+synchronized来保证并发安全，锁的粒度下降了 3、hashmap是线程不安全​ 1、多线程下对hashmap进行添加，删除，修改都可能会造成数据覆盖 ​ 2、jdk1.7扩容时容易导致死循环 4、putIfAbsent​ 1、map.putIfAbsent(key,value)，如果map中存在这个key，则返回key对应的值，如果不存在则返回null然后将值插入进去 二、比较器 Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制 某个类的次序，可以建立一个“该类的比较器”来进行排序。 ​ 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代 码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象 一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象， 那样就可以节省很多重复劳动了。 三、引用四、Cookie和Session1、存储位置​ 1、cookie存储在客户端，session存储在服务器 2、生成方式​ 1、第一次访问服务端时候，会创建一个session对象，并指定id为Jsessionid（Tomcat），然后响应给客户端，后续访问cookie里携带 Jsessionid，服务端识别，判断是不是上次会话，如果是则不会创建session对象 五、线程1、进程、线程、协程2、线程的地址空间3、线程池的七个参数问题​ 1、ThreadLocal、ThreadLocalMap、Thread区别 ​ (1)ThreadLocal内部类ThreadLocalMap，ThreadLocalMap的内部类Entry，Entry存储的键是ThreadLocal，值是调用ThreadLocal 的set方法设置的值Thread有个成员变量ThreadLocalMap， ThreadLocal.ThreadLocalMap threadLocals = null ​ 2、多线程哪些内存是共享的，哪些不是共享的 ​ (1)Java虚拟机在执行Java程序的时候会把它管理的内存划分为5个不同的区域，其中方法区和堆是线程共享的，而虚拟机栈、程序计 数器、本地方法栈是线程不共享的 ​ 3、一个线程能访问到另一个线程的局部变量吗 ​ 4、synchronized和volatile区别 六、Http1、三次握手​ 1、第一次握手：第一次握手是客户端发送同步报文到服务端，这个时候客户端是知道自己具备发送数据的能力的，但是不知道服务端 是否有接收和发送数据的能力。 ​ 2、第二次握手：当服务端接收到同步报文后，回复确认同步报文，此时服务端是知道客户端具有发送报文的能力，并且知道自己具有 接收和发送数据的能力，但是并不知道客户端是否有接收数据的能力。 ​ 3、第三次握手：当客户端收到服务端的确认报文后，知道服务端具备接收和发送数据的能力，但是此时服务端并不知道自己具有接收 的能力，所以还需要发送一个确认报文，告知服务端自己是具有接收能力的。 2、四次挥手​ 1、第一次挥手客户端发起关闭连接的请求给服务端 ​ 2、第二次挥手：服务端收到关闭请求的时候可能这个时候数据还没发送完，所以服务端会先回复一个确认报文，表示自己知道客户端 想要关闭连接了，但是因为数据还没传输完，所以还需要等待。 ​ 3、第三次挥手：当数据传输完了，服务端会主动发送一个 FIN 报文，告诉客户端，表示数据已经发送完了，服务端这边准备关闭连接 了。 ​ 4、第四次挥手：当客户端收到服务端的 FIN 报文过后，会回复一个 ACK 报文，告诉服务端自己`知道了，再等待一会就关闭连接。 3、Http状态码问题​ 1、为什么握手要三次，挥手却要四次呢 ​ 那是因为握手的时候并没有数据传输，所以服务端的 SYN 和 ACK 报文可以一起发送，但是挥手的时候有数据在传输，所以 ACK 和 FIN 报文不能同时发送，需要分两步，所以会比握手多一步。 ​ 2、为什么客户端在第四次挥手后还会等待 2MSL ​ 等待2MSL是因为保证服务端接收到了ACK报文，因为网络是复杂了，很有可能ACK报文丢失了，如果服务端没接收到ACK报文的 话，会重新发送FIN报文，只有当客户端等待了2MSL都没有收到重发的FIN报文时就表示服务端是正常收到了ACK报文，那么这个时候客 户端就可以关闭了。 ​ 3、浏览器输入一个url发生了什么 ​ 输入网址、解析域名、建立Tcp连接、发送请求报文、响应数据报文、关闭Tcp连接、渲染页面 ​ 4、get和post区别 ​ (1)GET在浏览器回退时是无害的，而POST会再次提交请求数据 ​ (2)GET参数通过URL传递，POST放在Request body中 ​ (3)GET请求会被浏览器主动缓存，而POST不会，除非手动设置 ​ (4)GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 ​ (5)GET请求在URL中传送的参数是有长度限制的，而POST没有 ​ (6)最大区别，get请求发送一个tcp数据包，post请求发送两个tcp数据包 七、GC八、数据在内存中存放的位置九、BIO、NIO、AIO十、对称加密和非对称加密十一、final、finally、finalize1、final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，比如 String 类 2、final 的变量是不可以修改的；Java 里用 final 修饰符去修饰一个方法的唯一正确用途就是表达：这个方法原本是一个虚方法，现在通 过 final 来声明这个方法不允许在派生类中进一步被覆写（override）。 3、finally 是 Java 保证重点代码一定要被执行的一种机制。可以使用 try-finally 或者 try-catch-finally 来进行关闭资源、保证 unlock 锁等 动作。 4、finalize 是基础类 java.lang.Object 的一个方法，设计目的是保证对象在被垃圾收集前完成特定资源的回收。 5、finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated 6、final修饰的变量必须初始化赋值或者构造方法里面赋值 7、static final修饰的变量必须初始化赋值或者在静态代码块里面赋值 十二、访问修饰符1、public : 对所有类可见。使用对象：类、接口、变量、方法 2、protected: 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类） 3、default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 4、private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） 十三、枚举1、每个枚举 其实都是class，且所有的枚举值都是 public static final 的，可用javap xxx.class查看。 1234567891011121314151617181920212223public enum Color{ RED, GREEN, BLUE;}通过javap ./Color.class查看public final class com.qz.nty.model.enums.Color extends java.lang.Enum&lt;com.qz.nty.model.enums.Color&gt; { public static final com.qz.nty.model.enums.Color RED; public static final com.qz.nty.model.enums.Color GREEN; public static final com.qz.nty.model.enums.Color BLUE; public static com.qz.nty.model.enums.Color[] values(); public static com.qz.nty.model.enums.Color valueOf(java.lang.String); static {};}values(), ordinal() 和 valueOf() 方法enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Serializable 和 java.lang.Comparable 两个接口。values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：values() 返回枚举类中所有的值。ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。valueOf()方法返回指定字符串值的枚举常量。枚举类中的抽象方法实现，需要枚举类中的每个对象都对其进行实现。 十四、序列化十五、SPI、factories1、SPI介绍​ SPI（Service Provider Interface），是JDK内置的一种服务提供发现机制，可以用来启用框架扩展和替换组件。JDK的spi机制提供了 ServiceLoader 类用于加载、解析spi接口的配置文件，ServiceLoader实现了Iterable接口，可迭代，但只能以迭代器的方式进行操作。 使用 hasNext() 时才会加载解析 META-INF/services 下对应的接口配置文件，使用 next() 时才会通过实现类的 Class 对象newInstance() 方法（实质是通过反射调用无参构造器）创建实例。 2、使用教程​ 在模块本身的resources下新建目录 META-INF/services，services目录下新建文件，以服务接口的全限定接口名作为文件名，文件中 指定该服务接口要使用的具体实现类。 1ServiceLoader.load(Class&lt;S&gt; service,ClassLoader loader) 3、Spring factories1、介绍​ factories可以看做是spring结合自身需要提供的一种spi机制，设计思想和jdk的spi机制差不多。factories机制在spring家族中广泛使用spring、springboot、springcloud中都大量使用了factories机制。spring体系的很多扩展配置都是通过spring.factories 指定的，比如应用初始化器 ApplicationContextInitializer、应用监听器ApplicationListener。注解本质是一种特殊接口，也可以用 factories 指定实现类，比如springboot中的 @EnableAutoConfiguration 注解就使用了factories指定要应用的实现类。 4、使用教程12SpringFactoriesLoader.loadFactories(Class&lt;T&gt; factoryType, @Nullable ClassLoader classLoader)SpringFactoriesLoader.loadFactoryNames(Class&lt;T&gt; factoryType, @Nullable ClassLoader classLoader) 5、区别​ jdk的spi机制，一个配置文件只能指定一个接口要使用的实现类；spring的factories机制，一个配置文件可以指定多个接口要使用的 实现类。 十六、数据类型1、基本类型(四类八种) ​ 1、byte：占一个字节，一个字节占八位，所以范围按2*位算，例如byte最小值-2^7，最大值2^7-1 ​ 2、short：两个字节 ​ 3、int：四个字节 ​ 4、long：八个字节 ​ 5、float：四个字节，使用4字节存储，精度可以精确到小数点后7位有效数字，在多数情况下，float类型精度很难满足需要。 ​ 6、double：八个字节，采用双精度存储，精度是float的2倍，绝大部分应用程序采用float类型。 ​ 7、char：UTF-8编码，一个字符占两个字节，GBK编码，一个字符占三个字节 ​ (1)example：字节和字符转换 123byte a = 97;System.out.println((char)a); // aSystem.out.println(byte('a')); // 97 ​ 8、boolean：Java虚拟机规范给出4个字节，1个字节、4个字节都是有可能的。这其实是运算效率和存储空间之间的博弈，两者都⾮常的重要。 2、引用类型","categories":[{"name":"Java","slug":"Java","permalink":"http://nty99.gitee.io/categories/Java/"}],"tags":[]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://nty99.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Linux","slug":"Linux","permalink":"http://nty99.gitee.io/categories/Linux/"},{"name":"中间件","slug":"中间件","permalink":"http://nty99.gitee.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"部署","slug":"部署","permalink":"http://nty99.gitee.io/categories/%E9%83%A8%E7%BD%B2/"},{"name":"数据库","slug":"数据库","permalink":"http://nty99.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java","slug":"Java","permalink":"http://nty99.gitee.io/categories/Java/"}],"tags":[]}